<!DOCTYPE html><html lang="zh-Hans"><head><!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]--><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="呼哧"><meta name="description" content="数论退役帖基本知识最大公因数找寻a,b的最大公因数, 利用辗转相除法：1234int gcd(int a, int b)&amp;#123;    return b?gcd(b,a%b):a;&amp;#125;// 或者直接使用自带函数 __gcd(a, b)常用定理$ gcd(a^n - 1, a^m - 1) = a^{gcd(n, m)} -1$扩展 $a&amp;gt;b, gcd(a, b)=1 时 gcd("><meta name="keywords" content="acm"><meta property="og:type" content="article"><meta property="og:title" content="数论退役帖"><meta property="og:url" content="http://hu-chi.github.io/2018/08/20/acm/数论/index.html"><meta property="og:site_name" content="Play with huchi"><meta property="og:description" content="数论退役帖基本知识最大公因数找寻a,b的最大公因数, 利用辗转相除法：1234int gcd(int a, int b)&amp;#123;    return b?gcd(b,a%b):a;&amp;#125;// 或者直接使用自带函数 __gcd(a, b)常用定理$ gcd(a^n - 1, a^m - 1) = a^{gcd(n, m)} -1$扩展 $a&amp;gt;b, gcd(a, b)=1 时 gcd("><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378748233_equation?tex=x"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378680406_equation?tex=a%5Bl%5D%5E%7Ba%5Bl%2B1%5D%5E%7Ba%5Bl%2B2%5D......%7D%7D"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378709031_equation?tex=mod"><meta property="og:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378718196_equation?tex=p"><meta property="og:updated_time" content="2018-08-19T18:32:47.795Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数论退役帖"><meta name="twitter:description" content="数论退役帖基本知识最大公因数找寻a,b的最大公因数, 利用辗转相除法：1234int gcd(int a, int b)&amp;#123;    return b?gcd(b,a%b):a;&amp;#125;// 或者直接使用自带函数 __gcd(a, b)常用定理$ gcd(a^n - 1, a^m - 1) = a^{gcd(n, m)} -1$扩展 $a&amp;gt;b, gcd(a, b)=1 时 gcd("><meta name="twitter:image" content="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="alternate" href="/atom.xml" title="Play with huchi" type="application/atom+xml"><link rel="shortcut icon" href="/img/huchi.jpg"><link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><title>数论退役帖 | Play with huchi</title><script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script>var yiliaConfig={fancybox:!0,animate:!0,isHome:!1,isPost:!0,isArchive:!1,isTag:!1,isCategory:!1,fancybox_js:"//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",scrollreveal:"//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",search:!0}</script><script>yiliaConfig.jquery_ui=[!0,"//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js","//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"]</script><script>yiliaConfig.rootUrl="/"</script></head></html><body><div id="container"><div class="left-col"><div class="overlay"></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/huchi.jpg" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/">呼哧</a></h1></hgroup><p class="header-subtitle">看遍南海风云卷，最恨难赴故人约。</p><form id="search-form"><input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search-result"></div><p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p><div id="switch-btn" class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-link hide" data-idx="2"><div class="loopback_l"></div><div class="loopback_r"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>菜单</li><li>标签</li><li>友情链接</li><li>关于我</li></ul></div></div><div id="switch-area" class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/随笔">随笔</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" href="/779197837@qq.com" title="Email"></a> <a class="fa GitHub" href="#" title="GitHub"></a> <a class="fa RSS" href="/atom.xml" title="RSS"></a></ul></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/">acm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/script/">script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/starts/">starts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端设计/">前端设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂书/">杂书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div></section><section class="switch-part switch-part3"><div id="js-friends"><a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a> <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a> <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a></div></section><section class="switch-part switch-part4"><div id="js-aboutme">专注于前端</div></section></div></div></header></div></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">呼哧</a></h1></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/huchi.jpg" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/" title="回到主页">呼哧</a></h1></hgroup><p class="header-subtitle">看遍南海风云卷，最恨难赴故人约。</p><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/随笔">随笔</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" target="_blank" href="/779197837@qq.com" title="Email"></a> <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a> <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a></ul></nav></header></div><link class="menu-list" tags="标签" friends="友情链接" about="关于我"></nav><div class="body-wrap"><article id="article-acm/数论" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/20/acm/数论/" class="article-date"><time datetime="2018-08-19T18:40:42.000Z" itemprop="datePublished">2018-08-20</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 class="article-title" itemprop="name">数论退役帖</h1></header><div class="article-info article-info-post"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/acm/">acm</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm/">acm</a></li></ul></div><div class="clearfix"></div></div><div class="article-entry" itemprop="articleBody"><h1 id="数论退役帖"><a href="#数论退役帖" class="headerlink" title="数论退役帖"></a>数论退役帖</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h3><p>找寻a,b的最大公因数, 利用辗转相除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者直接使用自带函数 __gcd(a, b)</span></span><br></pre></td></tr></table></figure><h4 id="常用定理"><a href="#常用定理" class="headerlink" title="常用定理"></a>常用定理</h4><ol><li>$ gcd(a^n - 1, a^m - 1) = a^{gcd(n, m)} -1$</li><li>扩展 $a&gt;b, gcd(a, b)=1 时 gcd(a^m-b^m, a^n- b^n) = a^{gcd(m, n)} - b^{gcd(m, n)}$</li><li>$G = gcd(C^1_n, C^2_n, …, C^{n-1}_n)$<ul><li>n为质数时G=n</li><li>n有多个质因子时，G=1</li><li>n有一个质因子p，G=p</li></ul></li><li>$F_n 为斐波那契额数列， gcd(F_n, F_m) = F_{gcd(n, m)}$</li><li>给定两个互素的正整数A,B， 那么他们组合的数C=p*A+q*B&gt;0， C最大为AB-A-B,不能组合的个数为$\frac{(A-1)*(B-1)}{2}$</li><li>$(n+1) lcm(C_n^0, C_n^1, .., C^n_n) = lcm(1, 2, 3, .. , n+1)$</li><li>对于质数p,$(x+y+…+w)^p \%p == (x^p + y^p + … + w^p) % p$</li></ol><a id="more"></a><h3 id="素数测定"><a href="#素数测定" class="headerlink" title="素数测定"></a>素数测定</h3><p>素数测定常用Miller-Rabin素数测试，是基于费马小定理 $a^p \equiv a(mod \ p ) p为质数$</p><p>反过来，如果满足该式子，p大多数为质数</p><p>Miller-Rabin 素数测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Times = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">multi</span><span class="params">(ll a, ll b ,ll m)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>; a%=m;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = (ans+a)%m;</span><br><span class="line">        a = (a+a)%m; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll b, ll m)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= m;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = multi(ans, a, m);</span><br><span class="line">        a = multi(a,a,m); b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((n&lt;<span class="number">2</span>) || !(n&amp;<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((m&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        k++; m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Times; i++)&#123;</span><br><span class="line">        ll a = rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        ll x = quick_mod(a,m,n);</span><br><span class="line">        ll y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            y = multi(x,x,n);</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!= n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = y;</span><br><span class="line">        &#125; <span class="keyword">if</span>(y!=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>51Nod 质数检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		BigInteger x;</span><br><span class="line">		x=cin.nextBigInteger();</span><br><span class="line">		<span class="keyword">if</span>(x.isProbablePrime(<span class="number">1</span>)) System.out.println(<span class="string">"Yes"</span>); <span class="comment">// java 自带Miller_Rabin</span></span><br><span class="line">		<span class="keyword">else</span> System.out.println(<span class="string">"No"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>对于二元一次方程 ax+by=gcd(a, b) 利用扩展欧几里得可以求得一组可行解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d=a,x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e_gcd(b,a%b,d,y,x);</span><br><span class="line">        y -= (a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a&gt;b时x为正数。可以令y=(y%a + a) % a 把y变成正数，再利用原始计算x</p><h3 id="毕达哥拉斯三元组本原解"><a href="#毕达哥拉斯三元组本原解" class="headerlink" title="毕达哥拉斯三元组本原解"></a>毕达哥拉斯三元组本原解</h3><p>对于$x^2 + y ^2 = z^2$ 我们只考虑本原解，即x,y,z互质。</p><p>这样的话，我们不妨假设x为偶数，y，z为奇数，那么就存在互质的数n,m</p><p>而且n,m一奇一偶且m&gt;n, 有$x=2 <em>m </em>n, y = m^2 - n ^ 2 , z= m^2 + n^2$</p><p><strong>POJ - 1305</strong></p><p>题意： 给一个正整数n求解，求解n的范围内gcd值为1的勾股数和不是勾股数的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> biao[N], n;</span><br><span class="line"><span class="keyword">bool</span> flag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(i,j)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)&amp;&amp;(j&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*i+j*j&lt;N)biao[i*i+j*j]++; <span class="comment">// 标记i^2+j^2即斜边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) biao[i]+=biao[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span> flag);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gcd(i,j)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((i&amp;<span class="number">1</span>)&amp;&amp;(j&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k*(i*i+j*j)&lt;=n; k++)&#123; <span class="comment">// 枚举斜边长并标记</span></span><br><span class="line">                    flag[<span class="number">2</span>*i*j*k]=flag[k*(i*i-j*j)]=flag[k*(i*i+j*j)]=<span class="number">1</span>; <span class="comment">// 标记使用过的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(flag[i])ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,biao[n],n-ans); </span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉函数与欧拉定理"><a href="#欧拉函数与欧拉定理" class="headerlink" title="欧拉函数与欧拉定理"></a>欧拉函数与欧拉定理</h4><p>我们定义欧拉函数$\phi (n) = 小于n且与n互质的数， \phi(1) = 1, \phi(2) = 1$</p><ol><li>m与n互素， $\phi(mn)=\phi(n)*\phi(m)$</li><li>$n = p_1^{a_1} p_2^{a_2} p_3^{a_3}… p_n^{a_n}, \phi(n) = n<em>(1 - \frac{1}{p_1})</em>(1 - \frac{1}{p_2})<em>(1 - \frac{1}{p_3})</em>…*(1 - \frac{1}{p_n}) $</li><li>$\sum_{d|n} \phi(d) = n$ 即n的因子的欧拉函数之和为n</li><li>a,m互质时, $x \equiv va^{\phi(m) - 1} 等价于 ax \equiv b(mod \ m)$ 事实上就是指数循环节</li></ol><p>容斥计算欧拉函数，复杂度$O(\sqrt{n})$：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans - ans/i; <span class="comment">// 减去i的倍数</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>)ans = ans-ans/n; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>欧拉筛是可以做到O(n) 预处理1-n之间所有的质因数， 通过对其修改，我们也能预处理出欧拉函数和莫比乌斯函数以及因数个数。一般欧拉函数不需要修改，可以作为模板.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// mu为莫比乌斯函数，d为因数个数， phi为欧拉函数， cnt为1-n质数个数</span></span><br><span class="line"><span class="keyword">int</span> mu[N],prime[N],d[N],ti[N],phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = d[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime[cnt++] = i; mu[i] = <span class="number">-1</span>;</span><br><span class="line">            d[i] = <span class="number">2</span>; ti[i] = <span class="number">1</span>; phi[i] = i<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N)<span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                ti[i*prime[j]] = ti[i] + <span class="number">1</span>;</span><br><span class="line">                d[i*prime[j]] = d[i]/(ti[i]+<span class="number">1</span>)*(ti[i]+<span class="number">2</span>);</span><br><span class="line">                phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; mu[i*prime[j]] = -mu[i];</span><br><span class="line">            d[i*prime[j]] = d[i]*<span class="number">2</span>;</span><br><span class="line">            ti[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            phi[i*prime[j]] = phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉例题"><a href="#欧拉例题" class="headerlink" title="欧拉例题"></a>欧拉例题</h3><h4 id="二次筛法-POJ-2689"><a href="#二次筛法-POJ-2689" class="headerlink" title="二次筛法 POJ - 2689"></a>二次筛法 <a href="https://vjudge.net/problem/10258/origin" target="_blank" rel="noopener">POJ - 2689</a></h4><blockquote><p>题意: 给出一个区间[L,U]，求给定区间内的质数距离最小的一对和质数距离最大的一对。U&lt;=1e9, U-L &lt;= 1e6</p><p>方法: 预处理$\sqrt{1e9} $ 的质数, 然后对[L, U] 区间内去晒(即标记)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> judge[<span class="number">21</span>*N], vis[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); uint u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v))&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">1</span>)u=<span class="number">2</span>; <span class="comment">// 1不是质数</span></span><br><span class="line">        <span class="built_in">memset</span>(judge,<span class="number">0</span>,<span class="keyword">sizeof</span> judge);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i] &lt;= v; i++)&#123;</span><br><span class="line">            uint j=((u<span class="number">-1</span>)/prime[i]+<span class="number">1</span>)*prime[i]; <span class="comment">// 第一个&gt;=u的prime[i]的倍数</span></span><br><span class="line">            <span class="keyword">if</span>(j == prime[i]) j += prime[i]; <span class="comment">// j为质数跳过</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt;= v; j+=prime[i]) judge[j-u]=<span class="number">1</span>; <span class="comment">// 晒去prime[i]的倍数</span></span><br><span class="line">        &#125; <span class="keyword">int</span> st,stlen=N,ed,edlen=<span class="number">0</span>,cot=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v-u; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!judge[i])&#123;  <span class="comment">// 即u+i为质数</span></span><br><span class="line">                <span class="keyword">if</span>(len &amp;&amp; len&lt;stlen)&#123;</span><br><span class="line">                    st = i-len; stlen = len; <span class="comment">//更新最近的质数对</span></span><br><span class="line">                &#125; <span class="keyword">if</span>(len &amp;&amp; len&gt;=edlen)&#123;</span><br><span class="line">                    ed = i-len; edlen = len; <span class="comment">//更新最远的质数对</span></span><br><span class="line">                &#125; cot++; len = <span class="number">0</span>; <span class="comment">// 统计区间质数个数</span></span><br><span class="line">            &#125; len ++ ;</span><br><span class="line">        &#125; <span class="keyword">if</span>(cot&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d,%d are closest, %d,%d are most distant.\n"</span>,u+st,u+st+stlen,u+ed,u+ed+edlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"There are no adjacent primes."</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-3939-直角三角形个数"><a href="#HDU-3939-直角三角形个数" class="headerlink" title="HDU - 3939 直角三角形个数"></a><a href="https://vjudge.net/problem/22080/origin" target="_blank" rel="noopener">HDU - 3939</a> 直角三角形个数</h4><blockquote><p>题意: 求a,b,c&lt;=L的三角形个数且满足a&lt;b&lt;c.abc互质. L &lt; 1e12</p></blockquote><blockquote><p>利用三元组本原解枚举n,m实现sqrt(1e12), 容斥去重</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">10</span>], phi[N], check[<span class="number">40</span>], cnt, num;</span><br><span class="line">ll ans, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;prime[cnt++]=i;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123; phi[i*prime[j]]=phi[i]*prime[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[n])&#123; check[num++]=n; <span class="keyword">return</span> ; &#125; <span class="comment">//n 为质数直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i]*prime[i] &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            check[num++]=prime[i];</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>) n/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) check[num++]=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容斥原理计算无关的数fun(j)=j-(j/c1+j/c2+j/c3)+(j/(c1*c2)+j/(c1*c3)+j/(c2*c3))-(j/(c1*c2*c3))。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) ans -= n/s;</span><br><span class="line">        <span class="keyword">else</span> ans+= n/s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; dfs(k+<span class="number">1</span>, r, s, n);</span><br><span class="line">    dfs(k+<span class="number">1</span>, r+<span class="number">1</span>, s*check[k], n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;L);</span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*L + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 枚举m ， n&lt;m 只要计算有多少符合n就行</span></span><br><span class="line">            <span class="keyword">int</span> p = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(L - (ll)i*i + <span class="number">0.5</span>); <span class="comment">// n的上界</span></span><br><span class="line">            <span class="keyword">if</span> ( i&lt;=p ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    prime_check(i); dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> ans += phi[i]; <span class="comment">// 对于偶数，与其互质的数都为奇数可以直接</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// i&gt;p时，j所取的范围在[1,p]</span></span><br><span class="line">                prime_check(i);</span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,p&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>对于$am \equiv 1 (mod \ m)$, 这个同余方程中最小的x正整数解叫做a模m的逆元;</p><p>也就是说$\frac{1}{a} \equiv x (mod \ m)$</p><p>由费马小定理得a对于模数mod为质数的逆元$a^{mod - 2}$可以用快速幂log求得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= mod;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a*a % mod;</span><br><span class="line">        k &gt;&gt; = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qp(a%mod, mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理逆元:</p><p>我们可预处理1-n的逆元是O(n)的复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) </span><br><span class="line">    inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br></pre></td></tr></table></figure><p>预处理n! 的逆元inv</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ll fac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[N<span class="number">-1</span>] = qp(fac[N<span class="number">-1</span>], mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-2</span>; i; i--) inv[i]=(i+<span class="number">1</span>)*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等比数列求和"><a href="#等比数列求和" class="headerlink" title="等比数列求和"></a>等比数列求和</h3><p>$S_n = (a + a^2 + .. + a^n) mod M$</p><p>如果使用高中的公式那么就是a = 1 时$s_n = n \mod \ M$, 如果a!=1, $S_n = \frac{a - a ^{n+1}}{1 - a}$</p><p>这里还有一种方法: 二分</p><p>对于n%2 == 0 $S_n = (1 + a ^{\frac{n}{2}}) S_{\frac{n}{2}}$</p><p>否则 $S_n = (1 + a^{\frac{n+1}{2}})S_{\frac{n+1}{2}} + a^{\frac{n+1}{2}}$</p><h4 id="POJ-3233-等比矩阵求和"><a href="#POJ-3233-等比矩阵求和" class="headerlink" title="POJ - 3233 等比矩阵求和"></a>POJ - 3233 等比矩阵求和</h4><p>如果利用上面的递推式子就可以解决矩阵的i次求和问题.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line">    Matrix()&#123; <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp); &#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; mp[i][i] = v; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123; <span class="keyword">if</span>(a.mp[i][k])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="keyword">if</span>(b.mp[k][j])</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][k]*b.mp[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">pls</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a.mp[i][j] = (a.mp[i][j]+b.mp[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">powmul</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Matrix c = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)c = multi(c,a);</span><br><span class="line">        a = multi(a,a); k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">S</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    Matrix temp = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        Matrix temp2 = powmul(a,(k+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> pls(multi(pls(temp, temp2), S(a,(k<span class="number">-1</span>)/<span class="number">2</span>)), temp2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Matrix temp2 = powmul(a,k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> multi(pls(temp, temp2), S(a,k/<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;mod))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a.mp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; a = S(a,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a.mp[i][j]);</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a.mp[i][n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个复杂度时有点高的,还可以构造矩阵利用矩阵快速幂一步到位。</p><p>我们要求的矩阵和为$S_n$</p><p>那么 $$ \begin{bmatrix} S_n \ A^n \end{bmatrix} = \begin{bmatrix}1 &amp; A \ 0 &amp; A \end{bmatrix} \begin{bmatrix} S_{n-1} \ A^{n-1} \end{bmatrix} $$</p><p>那么复杂度为O(60^3 * log k)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line">    Matrix()&#123; <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp); &#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; mp[i][i] = v; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123; <span class="keyword">if</span>(a.mp[i][k])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="keyword">if</span>(b.mp[k][j])</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][k]*b.mp[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">pls</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a.mp[i][j] = (a.mp[i][j]+b.mp[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">powmul</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Matrix c = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)c = multi(c,a);</span><br><span class="line">        a = multi(a,a); k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;mod))&#123;</span><br><span class="line">        Matrix a; <span class="keyword">int</span> g;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a.mp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g);</span><br><span class="line">                a.mp[i][j+n]=a.mp[i+n][j+n]=g%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; n *= <span class="number">2</span>; a = powmul(a, k); n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>+n; j &lt; n*<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,(a.mp[i][j])%mod);</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a.mp[i][<span class="number">2</span>*n])%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h3><p>从n个物品中选取k个物品有$C_n^{k}$ 种方法。</p><p>组合数表预处理 mod任意:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理阶乘， mod只能为质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[N<span class="number">-1</span>] = qp(fac[N<span class="number">-1</span>], mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-2</span>; i; i--) inv[i]=(i+<span class="number">1</span>)*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;</span><br></pre></td></tr></table></figure><p>Lucas 模数必须为小质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h3><p>有n组同余方程<br>$$<br>x \equiv a_1 (mod \ m_1) \ x \equiv a_2 (mod \ m_2) \ x \equiv a_3 (mod \ m_3) \ … \ x \equiv a_n (mod \ m_n) \<br>$$<br>利用CRT既可以解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    e_gcd(b, a%b, d, y, x);</span><br><span class="line">    y -= x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中国剩余定理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,d;</span><br><span class="line">        <span class="keyword">int</span> Mi = M/m[i];</span><br><span class="line">        e_gcd(Mi, m[i], d, x, y);</span><br><span class="line">        ans = (ans + Mi*x*a[i])%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans+= M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通中国剩余定理要求的$m_1,m_2,…,m_k$互素.但如果发生不互素时,需要采用两两合并.</p><h3 id="反素数"><a href="#反素数" class="headerlink" title="反素数"></a>反素数</h3><p>f(n)为n的因数个数，对于0&lt;i&lt;n，f(i) &lt; f(n), 则称n为反素数。</p><p>反素数一般满足质因数的幂次随着质因数的大小增大而减小</p><p>即 $若 n = 2^{t_1}3^{t_2}, 则必有t_1 \ge t_2$</p><h4 id="求最小的数使其因数为n-CF27E"><a href="#求最小的数使其因数为n-CF27E" class="headerlink" title="求最小的数使其因数为n  CF27E"></a>求最小的数使其因数为n CF27E</h4><p>n&lt;=1000，我们贪心的认为其质因数不会超过前50个质数，而且幂次不会超过63。</p><p>dfs暴力枚举加剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ll tmp, <span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//depth 为第几个质数, tmp为当前的值，um为因数个数</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; n || depth&gt;=cnt)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(num == n &amp;&amp; ans &gt; tmp)&#123;</span><br><span class="line">        ans = tmp; <span class="keyword">return</span>; <span class="comment">// 满足的情况下更新</span></span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i &lt;= <span class="number">63</span>; i++)&#123; <span class="comment">// 枚举幂次， 事实上可以记录上一次的幂次来优化剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(ans/prime[depth]&lt;tmp || num*(i+<span class="number">1</span>)&gt;n) <span class="keyword">return</span>; <span class="comment">// 用除法防止溢出</span></span><br><span class="line">        dfs(depth+<span class="number">1</span>, tmp*=prime[depth], num*(i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求1-n因数个数最大的数-URAL-1748"><a href="#求1-n因数个数最大的数-URAL-1748" class="headerlink" title="求1-n因数个数最大的数 URAL 1748"></a>求1-n因数个数最大的数 URAL 1748</h4><p>同样使用dfs暴力枚举</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ll ansa, <span class="keyword">int</span> ansb, <span class="keyword">int</span> limit)</span></span>&#123; <span class="comment">//ansa为值, ansb为因数个数</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt;= tot || ansa &gt; n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ansb &gt; b|| ((ansb == b) &amp;&amp; a&gt;ansa))&#123;</span><br><span class="line">        a = ansa; b = ansb;</span><br><span class="line">    &#125; <span class="keyword">for</span>(ll i = <span class="number">1</span>; depth &lt; tot &amp;&amp; i &lt;= limit; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansa &gt; n/prime[depth])<span class="keyword">break</span>;</span><br><span class="line">        dfs(depth+<span class="number">1</span>, ansa*=prime[depth], ansb*(i+<span class="number">1</span>), i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-4542"><a href="#HDU-4542" class="headerlink" title="HDU - 4542"></a><a href="https://vjudge.net/problem/37955/origin" target="_blank" rel="noopener">HDU - 4542</a></h4><blockquote><p>题意： X mod ai = bi 对于ai在区间 [1, X] 范围内每个值取一次时，有K个ai使bi等于0 。</p><p>告诉你有K个ai使得(不使得) bi等于0</p><p>找最小的X</p></blockquote><blockquote><p>解析：K个相等的时候我们去dfs暴力枚举，K个不相等的话这个数一定不大，先预处理</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) d[i] = i; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;N; j+=i) d[j]--; <span class="comment">// 容斥减去因子个数</span></span><br><span class="line">        <span class="keyword">if</span>(!d[d[i]]) d[d[i]] = i; <span class="comment">// 更新因子个数为d[i]位置的数为i， 节约了空间,这样也保是最小的</span></span><br><span class="line">        d[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> dfs(<span class="keyword">int</span> depth, ll ansa, <span class="keyword">int</span> ansb, <span class="keyword">int</span> limit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ansb &gt; k || depth &gt; <span class="number">16</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(ansb == k &amp;&amp; ansa&lt;ans)&#123;</span><br><span class="line">        ans = ansa; <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansa &gt; pos/prime[depth] || ansb*(i+<span class="number">1</span>)&gt;k) <span class="keyword">break</span>;</span><br><span class="line">        ansa*=prime[depth];</span><br><span class="line">        <span class="keyword">if</span>(k%(ansb*(i+<span class="number">1</span>))==<span class="number">0</span>) dfs(depth+<span class="number">1</span>, ansa, ansb*(i+<span class="number">1</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> T,t=<span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(t++&lt;T) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;type,&amp;k); ans = flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(type) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[k]) <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,t,d[k]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: Illegal\n"</span>,t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ~<span class="number">0u</span>ll; dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">63</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; inf) <span class="built_in">printf</span>(<span class="string">"Case %d: INF\n"</span>,t);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>,t,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数循环节"><a href="#指数循环节" class="headerlink" title="指数循环节"></a>指数循环节</h2><p>$$a^b \equiv a^{b \% \phi(c)+\phi(c)}(mod \ c),b&gt;\phi(c) $$</p><p>例题 <a href="https://vjudge.net/problem/HDU-4335" target="_blank" rel="noopener">C - What is N?</a></p><p>这里求$$n^{n!} \equiv b(mod \ p)$$有多少个成立的n，对于指数%phi(p)为0后的数，是存在循环节的。只要记录一下一次循环的个数p，最后多余的部分去跑一下记忆化的就知道有多少组了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            res = res - res/i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res - res/n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickmod</span><span class="params">(ll a, ll b, ll c)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%c;</span><br><span class="line">        a = a*a%c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll b, p, m, fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(t++&lt;T)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64u%I64u%I64u"</span>, &amp;b, &amp;p, &amp;m); <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>,t);</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">18446744073709551615u</span>ll) <span class="built_in">printf</span>(<span class="string">"18446744073709551616\n"</span>); <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,m+<span class="number">1</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ll i = <span class="number">0</span>, ans = <span class="number">0</span>, fac = <span class="number">1</span>;</span><br><span class="line">            ll phic = phi(p);</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m &amp;&amp; fac&lt;=phic; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(quickmod(i, fac, p) == b) ans ++; <span class="comment">// 计算n! &lt;= phi(p)的个数</span></span><br><span class="line">                fac *= i+<span class="number">1</span>;</span><br><span class="line">            &#125; fac = fac%phic; <span class="comment">//指数循环节公式</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt;= m &amp;&amp; fac; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(quickmod(i, fac + phic, p) == b) ans++;</span><br><span class="line">                fac = (fac*(i+<span class="number">1</span>))%phic;</span><br><span class="line">            &#125; <span class="comment">// 至多跑一个循环或者不超过M</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= m)&#123;</span><br><span class="line">                ll cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++)&#123;</span><br><span class="line">                    fa[j] = quickmod(i+j, phic, p); <span class="comment">// 记忆化p长度的循环</span></span><br><span class="line">                    <span class="keyword">if</span>(fa[j] == b) cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">                ll idx = (m-i+<span class="number">1</span>)/p; <span class="comment">// 循环个数</span></span><br><span class="line">                ans += cnt * idx;   <span class="comment">// 循环的种数</span></span><br><span class="line">                ll remain = (m-i+<span class="number">1</span>)%p; <span class="comment">// 不足一个循环的数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; remain; j++) <span class="keyword">if</span>(fa[j] == b) ans ++ ;</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>牛客练习赛 22E</strong></p><blockquote><p>题意：给一个长为n的序列，m次操作，每次操作：</p><p>1.区间<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D" alt="img">加<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378748233_equation?tex=x" alt="img"></p><p>2.对于区间<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D" alt="img">，查询<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378680406_equation?tex=a%5Bl%5D%5E%7Ba%5Bl%2B1%5D%5E%7Ba%5Bl%2B2%5D......%7D%7D" alt="img"><img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378709031_equation?tex=mod" alt="img"> <img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378718196_equation?tex=p" alt="img">，一直到$a_r$</p><p>请注意每次的模数不同。</p></blockquote><p>区间加值我们可以考虑使用线段树lazy标记，查询就直接使用指数循环节公式倒过来计算就行了。</p><p>这道题因为数据太多，用文件读入才能过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e7</span>+<span class="number">9</span>;</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="keyword">bool</span> judge[M];</span><br><span class="line"><span class="keyword">int</span> prime[M],p[M],mod[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_SIZE 100000</span></span><br><span class="line">  <span class="comment">//fread-&gt;read</span></span><br><span class="line">  <span class="keyword">bool</span> IOerror=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">      p1=buf; pend=buf+fread(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdin</span>);</span><br><span class="line">      <span class="keyword">if</span> (pend==p1)&#123;IOerror=<span class="number">1</span>;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">      <span class="comment">//&#123;printf("IO error!\n");system("pause");for (;;);exit(0);&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;<span class="keyword">return</span> ch==<span class="string">' '</span>||ch==<span class="string">'\n'</span>||ch==<span class="string">'\r'</span>||ch==<span class="string">'\t'</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">double</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'.'</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> tmp=<span class="number">1</span>; ch=nc();</span><br><span class="line">      <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())tmp/=<span class="number">10.0</span>,x+=tmp*(ch-<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch;</span><br><span class="line">    *s=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (c=nc();blank(c);c=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)&#123;c=<span class="number">-1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fwrite-&gt;write</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Ostream_fwrite</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *buf,*p1,*pend;</span><br><span class="line">    Ostream_fwrite()&#123;buf=<span class="keyword">new</span> <span class="keyword">char</span>[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">        fwrite(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdout</span>);p1=buf;</span><br><span class="line">      &#125;</span><br><span class="line">      *p1++=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">15</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">15</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1); out(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">25</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">25</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1); out(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> ll mul[]=&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>,<span class="number">1000000</span>,<span class="number">10000000</span>,<span class="number">100000000</span>,</span><br><span class="line">        <span class="number">1000000000</span>,<span class="number">10000000000L</span>L,<span class="number">100000000000L</span>L,<span class="number">1000000000000L</span>L,<span class="number">10000000000000L</span>L,</span><br><span class="line">        <span class="number">100000000000000L</span>L,<span class="number">1000000000000000L</span>L,<span class="number">10000000000000000L</span>L,<span class="number">100000000000000000L</span>L&#125;;</span><br><span class="line">      <span class="keyword">if</span> (x&lt;<span class="number">-1e-12</span>)out(<span class="string">'-'</span>),x=-x;x*=mul[y];</span><br><span class="line">      ll x1=(ll)<span class="built_in">floor</span>(x); <span class="keyword">if</span> (x-<span class="built_in">floor</span>(x)&gt;=<span class="number">0.5</span>)++x1;</span><br><span class="line">      ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2);</span><br><span class="line">      <span class="keyword">if</span> (y&gt;<span class="number">0</span>)&#123;out(<span class="string">'.'</span>); <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];out(<span class="string">'0'</span>),++i); print(x3);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;print(x,y);out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;<span class="keyword">while</span> (*s)out(*s++);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;<span class="keyword">while</span> (*s)out(*s++);out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="keyword">if</span> (p1!=buf)&#123;fwrite(buf,<span class="number">1</span>,p1-buf,<span class="built_in">stdout</span>);p1=buf;&#125;&#125;</span><br><span class="line">    ~Ostream_fwrite()&#123;flush();&#125;</span><br><span class="line">  &#125;Ostream;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Ostream.print(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Ostream.println(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;Ostream.out(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;Ostream.out(x);Ostream.out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;Ostream.print(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(ll x)</span></span>&#123;Ostream.println(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;Ostream.print(x,y);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;Ostream.println(x,y);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;Ostream.print(s);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;Ostream.println(s);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;Ostream.out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;Ostream.flush();&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OUT_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!judge[i])&#123; prime[tot++]=i; p[i] = i<span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=M)<span class="keyword">break</span>; judge[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>)&#123; p[i*prime[j]] = p[i]*prime[j]; <span class="keyword">break</span>;&#125; </span><br><span class="line">            p[i*prime[j]]=p[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">return</span> p[n]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quickmod</span><span class="params">(ll a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= c;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%c;</span><br><span class="line">        a = a*a%c; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(ll a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="comment">// 指数循环节公式</span></span><br><span class="line">    <span class="keyword">if</span>(b*<span class="built_in">log</span>(a) &gt;= <span class="built_in">log</span>(c)) <span class="keyword">return</span> quickmod(a, b, c)+c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickmod(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,op;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树模板</span></span><br><span class="line"><span class="keyword">namespace</span> sgt &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> chg[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">1000010</span>][<span class="number">2</span>],cnt,root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        x=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(son[x][<span class="number">0</span>],l,mid);</span><br><span class="line">        build(son[x][<span class="number">1</span>],mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b || l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=l &amp;&amp; b&gt;=r)chg[k]+=v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b&lt;=mid)update(a,b,son[k][<span class="number">0</span>],l,mid,v);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;mid)update(a,b,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v);</span><br><span class="line">            <span class="keyword">else</span> update(a,mid,son[k][<span class="number">0</span>],l,mid,v),update(mid+<span class="number">1</span>,b,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> v+chg[k]+val[a];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)<span class="keyword">return</span> query(a,son[k][<span class="number">0</span>],l,mid,v+chg[k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(a,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v+chg[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    init(); read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(val[i]);</span><br><span class="line">    sgt::build(sgt::root,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m; t++) &#123;</span><br><span class="line">        read(op); ll x; <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            read(l); read(r); read(x);</span><br><span class="line">            sgt::update(l, r, sgt::root, <span class="number">1</span>, n, x); <span class="comment">// 区间加值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(l); read(r); read(x); <span class="keyword">int</span> ans = <span class="number">1</span>; mod[l] = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">                mod[i] = phi(mod[i<span class="number">-1</span>]); <span class="comment">// 预处理幂次的幂次的模数</span></span><br><span class="line">                <span class="keyword">if</span>(mod[i] &lt;= <span class="number">2</span>) r = i; <span class="comment">// 某幂次&lt;2那么基本就是0了可以停止了</span></span><br><span class="line">            &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--)&#123;</span><br><span class="line">                ans = slove(sgt::query(i, sgt::root, <span class="number">1</span>, n, <span class="number">0</span>), ans, mod[i]); <span class="comment">//单点查询，倒着计算</span></span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans%x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><h4 id="积性函数的定义"><a href="#积性函数的定义" class="headerlink" title="积性函数的定义"></a>积性函数的定义</h4><ol><li>若$f(n)$的定义域为正整数域，值域为复数，即$f:Z+→Cf:Z+→C$，则称f(n)为<strong>数论函数</strong>。</li><li>若f(n)为数论函数，且f(1)=1，对于互质的正整数p,q有f(p⋅q)=f(p)⋅f(q)，则称其为<strong>积性函数</strong>。</li><li>若f(n)为积性函数，且对于任意正整数p,q都有f(p⋅q)=f(p)⋅f(q)，则称其为<strong>完全积性函数</strong>。</li></ol><h3 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数"></a>常见的积性函数</h3><ol><li>除数函数$\sigma_k(n) = \sum_{d|n} d^k$, 表示n的约数的k次幂和</li><li>约数个数函数$d(n) = \sigma_0(n) = \sum_{d|n} 1$ , 表示约数个数</li><li>约数和函数$\sum_{d|n} d$</li><li>欧拉函数$\phi(n)=\sum_{i=1}^{n} [(n, i) == 1]$, 对于n&gt;=2 有 $\phi(n)=\sum_{i=1}^{n} [(n, i) == 1] · i = n\phi(n)/2 $</li><li>莫比乌斯函数$u(n)$, 与恒等函数互为逆元</li><li>元函数 $e(n) = [n == 1]$</li><li>恒等函数$I(n) = 1$</li><li>单位函数$id(n) =n$</li><li>幂函数$id^k(n) = n^k$</li></ol><h4 id="两个常用的公式"><a href="#两个常用的公式" class="headerlink" title="两个常用的公式"></a>两个常用的公式</h4><ol><li>$e(n) = \sum_{d|n}u(d)$, 可以将u(d)看作是容斥的系数</li><li>$n = \sum_{d|n} \phi(d)$</li></ol><h4 id="积性函数性质"><a href="#积性函数性质" class="headerlink" title="积性函数性质"></a>积性函数性质</h4><p>若f(n)为积性函数，对于正整数$n = p_{1}^{k_1}p_{2}^{k_2}…p_{n}^{k_n}$</p><p>有$f(n)=\prod_{i=1}^{t}{f(p_i^{k_i})} $, 对于完全积性函数有$f(n)=\prod_{i=1}^{t}{f(p_i)^{k_i}}$</p><h3 id="分块技巧"><a href="#分块技巧" class="headerlink" title="分块技巧"></a>分块技巧</h3><p><a href="https://vjudge.net/problem/341399/origin" target="_blank" rel="noopener">UVALive - 7426</a></p><blockquote><p>题意：有一份包含个 bug 的n( 1≤𝑛≤$ 10^6 $)行代码，运一次到崩溃需要的时间为 r( 1≤𝑟≤$ 10^9 $)。你可以任意行添加 printf 语句来输出调试,即你知道是否在执行 printf 语句前就崩溃了。每设置一个 printf语句需要花费 p( 1≤𝑝≤$10^9$)</p><p>问最坏的情况下，最少需要多少时间可以定位bug的行数</p></blockquote><blockquote><p>解释：我们设置f(n)为n行代码debug需要的最少时间。那么对于f(n)我们时可以由前面的状态转移过来的，我们对于n行代码分成2块，那么我们就需要f ( (n+1)/2 ) + r + p的时间， 我们分成k块，那么最大的块的大小就为 (n+k-1)/k 向下取整个， 所以总体时间就是 f((n+k-1)/k) + r + (k-1)*p;</p><p>这样我们从1-n递推过来就是O(n^2) 的算法， 我们要考虑优化， 随着k增大，我们会发现有很多(n+k-1)/k 是相同，但是我们应该取相同种k最小的，所以我们反过来枚举(n+k-1)/k的大小，也就是每个块最大为l， 那么最多有(n+l-1)/l 块， 所以这样总体时间就是f(l) + r +( (n+l-1)/l )* p;</p><p>对于n√n的算法还是很吃力的，我们考虑使用记忆化搜索来降低复杂度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> n, r, p, vis[N], t;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[n] == t || n == <span class="number">1</span>) <span class="keyword">return</span> f[n];  <span class="comment">// 如果已经计算过直接返回</span></span><br><span class="line">    ll ans = <span class="number">1e18</span>+<span class="number">7</span>; vis[n] = t; <span class="comment">// 表示t组样例的时候f[n]被跟新了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(n+<span class="number">0.5</span>); j++) &#123;</span><br><span class="line">        ans = min(ans, dfs((n+j)/(j+<span class="number">1</span>)) + r + <span class="number">1L</span>L*j*p); <span class="comment">// 枚举j+1块</span></span><br><span class="line">        ans = min(ans, dfs(j)+r+((n+j<span class="number">-1</span>)/j<span class="number">-1L</span>L)*p);     <span class="comment">// 枚举每块最大为j个</span></span><br><span class="line">    &#125; <span class="keyword">return</span> f[n] = ans; <span class="comment">// 记忆化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;r, &amp;p)) &#123;</span><br><span class="line">        t++; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(n));   <span class="comment">//每组，记忆话搜索一下</span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪利克雷卷积"><a href="#迪利克雷卷积" class="headerlink" title="迪利克雷卷积"></a>迪利克雷卷积</h3><p>设f,g为两个数论函数，则满足$h(n) = \sum_{d|n} f(d)g(\frac{n}{d})$ 称为f与g的迪利克雷卷积。</p><h4 id="积性函数例题-HDU-5528"><a href="#积性函数例题-HDU-5528" class="headerlink" title="积性函数例题 HDU - 5528 "></a>积性函数例题 <a href="https://vjudge.net/problem/271392/origin" target="_blank" rel="noopener">HDU - 5528</a></h4><blockquote><p>题意：f(n)=为[0, n)种选2个数a,b且ab不为n的倍数的方案数。</p><p>求$g(n) = \sum_{d|n} f(d) \% 2^{64}$</p><p>$1 \le T \le 2e4, 1 \le n \le 1e9$</p></blockquote><blockquote><p>解析：我们先考虑f(n) ， f(n) = n*n - ab为n的倍数的方案数</p><p>即$f(n) = n^2 - \sum_{d|n}\phi(\frac{n}{d})d$</p><p>令$h(n) = \sum_{d|n}\phi(\frac{n}{d})d$</p><p>那么原式=$\sum_{d|n}d^2 - \sum_{d|n}h(d)$, 很显然这两个函数都是积性函数，我们如果直接对其质因数分解是可以做的。不过处理后面的还是很麻烦。</p><p>$\sum_{d|n}\sum_{w|d}\phi(w) * \frac{d}{w} = \sum_{w|n}w· \sum_{\frac{d}{w} |\frac{n}{w} } \phi(\frac{d}{w}) = \sum_{w|n} n = n·d(n)$</p><p>这样处理就方便了很多</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lll = <span class="keyword">unsigned</span> __int128;</span><br><span class="line">ll a[N], num[N], cnt, prime[N], tot, n;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> j prime[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1L</span>L*j*j &lt;= n &amp;&amp; i &lt; tot; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">            num[cnt] = <span class="number">0</span>; a[cnt] = j;</span><br><span class="line">            <span class="keyword">while</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">                num[cnt]++; n /= j;</span><br><span class="line">            &#125; cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) a[cnt]=n,num[cnt++]=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> j</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">qp</span><span class="params">(lll a, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// 快速幂</span></span><br><span class="line">    lll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans *= a;</span><br><span class="line">        a *= a; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">p</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) ans *= (qp(a[i], num[i]*<span class="number">2</span>+<span class="number">2</span>)<span class="number">-1</span>)/(a[i]*a[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">q</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) ans *= num[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); cnt = <span class="number">0</span>; d(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, p(n) - q(n));</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="积性函数习题-757E"><a href="#积性函数习题-757E" class="headerlink" title="积性函数习题 757E"></a>积性函数习题 757E</h4><blockquote><p>题意: $f_0 (n)$ 为 (p, q) == 1, 且p*q = n的个数, $f_{r+1}(n) = \sum_{u * v=n} \frac{f_{r}(u) + f_{r}(v)}{2} $</p><p>求$f_r(n) \%1e9+7$</p></blockquote><blockquote><p>解释： 显然$f_0(n) = 2^{n的质因子个数}$，这是一个积性函数，我们可以对其化简$f_0(n) = f_0(p_1^{k_1})f_0(p_2^{k_2})…f_0(p_t^{k_t}) = \prod_{i=1}^t(1+k_i)$</p><p>f(p^k)只与k有关，而k又是logn的，由$f_r(n)$定义可知这是一个积性函数，所以做r次前缀和就可以了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line">ll f[N][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) f[<span class="number">0</span>][i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) f[i][j] = (f[i][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j])%mod; <span class="comment">//前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q, r, n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> j prime[i]</span></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; j*j &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%j==<span class="number">0</span>)n/=j,t++; <span class="comment">// 算p^k</span></span><br><span class="line">            ans = (ans * f[r][t])%mod;  <span class="comment">//计算每个质因数的贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans = (ans * f[r][<span class="number">1</span>]) % mod; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> j</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, d(n));</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n) = \sum_{d|n} g(d) &lt;=&gt; g(n) = \sum_{d|n}u(d)f(\frac{n}{d})<br>$$</p><p>这就是莫比乌斯函数，对于已知的f(n)，我们都可以利用该等式来反过来求g(n);</p><h4 id="经典例题-求互质的数对数-HDU-1695"><a href="#经典例题-求互质的数对数-HDU-1695" class="headerlink" title="经典例题-求互质的数对数 HDU - 1695"></a>经典例题-求互质的数对数 <a href="https://vjudge.net/problem/21352/origin" target="_blank" rel="noopener">HDU - 1695</a></h4><blockquote><p>题意：求1&lt;=i&lt;=b, 1&lt;=j&lt;=d 由多少对(i,j)满足gcd(i, j) = k</p></blockquote><blockquote><p>解析：我们先解决1&lt;=i&lt;=n, 1&lt;=j&lt;=m. gcd(i, j)== 1的问题</p><p>令F(d) 为有多少对i，j满足gcd(i, j) == d的倍数</p><p>f(d) 为有多少对gcd(i, j) == d， 那么我们就有$F(d) = \sum _{}f(id)$, $f(1) = \mu(1)F(1) + \mu(2)F(2)+…$</p><p>显然$f(1) = \sum_{i=1}^{min(n, m)} \mu(i) F(i)= \sum_{i=1}^{min(n, m)} \mu(i) \frac{n}{i} \frac{m}{i}$,</p><p>利用分块就可以做到$\sqrt{n}+\sqrt{m}$ 查询</p><p>所以对于原问题，b,d/=k就转成了gcd(i,j)==1, 再去减去不符合的就可以了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> mu[N], prime[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;N)<span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]]= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>)&#123; mu[i*prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">slove</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// 分块</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= l; i=tmp+<span class="number">1</span>) &#123;</span><br><span class="line">        tmp = min(l/(l/i), r/(r/i));</span><br><span class="line">        ans += (ll)(mu[tmp]-mu[i<span class="number">-1</span>])*(l/i)*(r/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b,d,k,T=<span class="number">0</span>, t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%*d%d%*d%d%d"</span>,&amp;b,&amp;d,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(!k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: 0\n"</span>,++T); <span class="keyword">continue</span>;</span><br><span class="line">        &#125; b/=k;d/=k; <span class="keyword">if</span>(b &gt; d) swap(b, d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,++T,slove(b,d) - slove(b, b)/<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GCD表中的质数"><a href="#GCD表中的质数" class="headerlink" title="GCD表中的质数"></a>GCD表中的质数</h4><blockquote><p>题意：有一个M * N的表格，行与列分别是1 - M和1 - N，格子中间写着行与列的最大公约数Gcd(i, j)(1 &lt;= i &lt;= M, 1 &lt;= j &lt;= N)。 求质数个数。</p></blockquote><blockquote><p>解析：我们枚举p,利用上面的结论就有$ans = \sum_{p}\sum_{i=1}^{\frac{n}{p}} \lfloor \frac{n}{ip} \rfloor \lfloor \frac{m}{ip} \rfloor$ , 根据这个公式的复杂度$O(T (\frac{n}{log\ n}·(\sqrt{n}+\sqrt{m}) ) )$ , 这样复杂度有点高，我们对原始做一些优化，交换两个求和符号就可以得到$\sum_{i=1}^{n}\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor \sum_{j|i}\mu(\frac{i}{j}) \&amp;\&amp; j 为质数$</p><p>如果我们预处后面的一个求和，那么就可以做到分块查询</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">5</span>], mu[N], cnt, n, m;</span><br><span class="line">ll f[N]; <span class="comment">// 为后一个求和</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++] = i; mu[i]=<span class="number">-1</span>; f[i]=<span class="number">1</span>;&#125; <span class="comment">// 对于质数f[i] = mu[1] = 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123; f[i*prime[j]] = mu[i]; <span class="keyword">break</span>; &#125; <span class="comment">//prime[j]次数为2时，之前的u都变成了0，只剩下p=prime[j],所以f[i*prime[j]]=mu[i];</span></span><br><span class="line">            f[i*prime[j]] = -f[i] + mu[i]; mu[i*prime[j]] = -mu[i]; <span class="comment">//次数为1时，u变成原来的相反数，再多上新增的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i] += f[i<span class="number">-1</span>]; <span class="comment">// 前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// 分块查询</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = min(n/(n/i), m/(m/i));</span><br><span class="line">        ans += (f[j]-f[i<span class="number">-1</span>])*(n/i)*(m/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); init();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="keyword">if</span>(n &gt; m) swap(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(n, m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如此类的还有</p><ol><li>$\sum_{a=1}^{N} \sum_{b=1}^M gcd(a, b) = \sum_{d=1}^{min(N, M)} \phi(d) \lfloor \frac{N}{d} \rfloor \lfloor \frac{M}{d} \rfloor$</li><li>$\sum_{a=1}^{N} \sum_{b=1}^M lcm(a, b) = \frac{1}{4}\sum_{d=1}^{min(N, M)} \lfloor \frac{N}{d} \rfloor \lfloor \frac{M}{d} \rfloor(\lfloor \frac{N}{d} \rfloor + 1)(\lfloor \frac{M}{d} \rfloor+1) d \sum_{d’|d}d’u(d’) $</li><li>$\sum_{a=1}^{N} \sum_{b=1}^N lcm(a, b) = \sum_{i=1}^N (-i+2\sum_{j=1}^ilcm(i,j))$, 预处理后可以O(1)输出</li><li>$\sum_{i=1}^n gcd(i, n) = \sum_{d|n}\phi(d) \frac{n}{d}$</li><li>$\sum_{i=1}^n e(gcd(i, n)) = \sum_{d|n}\mu(d) \frac{n}{d}$</li><li>约束和之和$\sum_{i=1}^n = \sum_{i=1}^n i \lfloor \frac{n}{i} \rfloor$</li><li>$g(n)=\frac{n}{2}(\phi(n)+e(n))$</li><li>$\sum_{i=1}^n lcm(i, n) = n\sum_{d|n}g(\frac{n}{d})$</li><li>$\sum_{i=1}^n\sum_{j=1}^mij = \frac{n(n+1)m(m+1)}{4}$</li><li>$\sum_{i=1}^n\sum_{j=1}^mij · e(gcd(i,j)) = \sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor}ij$</li></ol><h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><p>设$S(n) = \sum_{i=1}^n f(i)$, 若存在数论函数g,设$h=f*g$, 则有$\sum_{i=1}^{n}h(i)=\sum_{i=1}^ng(i)S(\lfloor \frac{n}{i} \rfloor)$ , 化简得</p><p>$g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)S(\lfloor \frac{n}{i} \rfloor)$,</p><p>如果我们可以$O(sqrt{n})$计算 $\sum_{i=1}^n h(i)$, O(1)计算g(n)前缀和，那么我们就可以分块查询S(n), 复杂度为$O(n^{\frac{3}{4}})$, 如果预处理前$n^{\frac{3}{4}}$ 项就可以优化到$O(n^{\frac{3}{4}})$,</p><h4 id="欧拉函数前缀和-51nod-1239"><a href="#欧拉函数前缀和-51nod-1239" class="headerlink" title="欧拉函数前缀和 51nod 1239"></a>欧拉函数前缀和 51nod 1239</h4><blockquote><p>题意：求$\sum_{i=1}^n \phi(n)$ , n &lt; 1e11;</p></blockquote><blockquote><p>解析：$S（n）= \sum_{i=1}^n i - \sum_{i=2}^n 1 *S(\lfloor \frac{n}{i} \rfloor)$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp; <span class="comment">// 记忆化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            prime[cnt++] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) &#123; phi[i*prime[j]] = phi[i]*prime[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            phi[i*prime[j]] = phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) phi[i] = (phi[i<span class="number">-1</span>] + phi[i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a* a %mod; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;ll inv2 = qp(<span class="number">2</span>, mod<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> phi[n]; <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">if</span>(mp.find(n) != mp.end()) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = n%mod*(n%mod+<span class="number">1</span>)%mod*inv2%mod; <span class="comment">// n*(n+1)/2</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123; <span class="comment">// 分块</span></span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans - (j-i+<span class="number">1</span>)%mod*dfs(n/i)%mod) %mod; <span class="comment">// 1 从i加到j = (j-i+1)</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=(ans%mod + mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(n)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="莫比乌斯函数前缀和"><a href="#莫比乌斯函数前缀和" class="headerlink" title="莫比乌斯函数前缀和"></a>莫比乌斯函数前缀和</h4><blockquote><p>题意：求$\sum_{i=1}^n \mu(i)$, i &lt;= 1e10</p></blockquote><blockquote><p>解析：u*I=e, 所以$S(n) = 1 - \sum_{i=2}^n S(\lfloor \frac{n}{i} \rfloor )$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;ll mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> mu[n];</span><br><span class="line">    <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="comment">// e</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i); ans -= dfs(n/i)*(j-i+<span class="number">1</span>); <span class="comment">// 和上一题一样</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b); init();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(b)-dfs(a<span class="number">-1</span>)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一道习题 ：</p><p>$N^2-3N+2=\sum_{d|N} f(d)$, 求$\sum_{i=1}^Nf(i)\ mod \ 1e9+7, N \le 1e9$</p><p>这道题很容易用杜教筛做，不过他的前1e7前缀预处理可以用容斥来写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        f[i] = (i<span class="number">-1L</span>L)*(i<span class="number">-2L</span>L)%mod;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt; N; j+=i)</span><br><span class="line">            f[j] = ((f[j]-f[i])+mod)%mod; <span class="comment">// 容斥</span></span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i]=(f[i]+f[i<span class="number">-1</span>])%mod; <span class="comment">// 前缀和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extended-Eratosthenes-Sieve洲阁筛"><a href="#Extended-Eratosthenes-Sieve洲阁筛" class="headerlink" title="Extended Eratosthenes Sieve洲阁筛"></a>Extended Eratosthenes Sieve<strong>洲阁筛</strong></h3><p>洲阁筛时一种在$O(\frac{n^{\frac{3}{4}}}{log \ n})$ 时间内计算大多数积性函数的前缀和的方法。</p><p>F(x)是一个积性函数，要求在低于线性的时间内求出。当p为质数时，$F(p^c)$是关于p的低阶多项式。</p><p>对于1-n中的所有数，我们按照是否含有&gt;$\sqrt{n}$ 的质因子分为两类，则显然有<br>$$<br>\sum_{i=1}^n F(i) = \sum_{i=1 \&amp;\&amp; i没有大于\sqrt{n} 的质因数}^n F(i)(1 + \sum_{\sqrt{n}\le j \le \lfloor \frac{n}{i} \rfloor \&amp; \&amp; j为质数} F(j)\ \ \ )<br>$$</p><p>事实上，我们可以预处理 $ 1 \le i &lt; \sqrt{n} $ 的F, 那么现在的问题就是要解决</p><ol><li>$\sum_{\sqrt{n} &lt; j &lt; \le \lfloor \frac{n}{i} \&amp;\&amp;j为质数\rfloor} F(j)$</li></ol><p>我们令g(i, j) 表示[1, j]中与前i各质数互质的数的k次幂和。显然有<br>$$<br>g(i, j) = g(i-1, j)-p^k_ig(i-1, \lfloor \frac{j}{p_i}\rfloor) \<br>p_i^2 &gt; j时 g(i, j) = g(i-1, j) - p^k_i<br>$$</p><ol start="2"><li>$$\sum_{\sqrt{n} \le i \le n \&amp;\&amp; i 没有质因数&gt;\sqrt{n}} F(i)$$</li></ol><p>设f(i, j) 表示[1, j]中仅由i个质数个组成的数的F(x)之和<br>$$<br>f(i, j) = f(i-1, j) + \sum_{c \ge 1}F(p^c_i)f(i-1, \lfloor \frac{j}{p_i^c} \rfloor) \<br>当p^2_i &gt; j 时， f(i, j) = f(i-1, j) + F(p_i)<br>$$</p><h4 id="素数个数"><a href="#素数个数" class="headerlink" title="素数个数"></a>素数个数</h4><blockquote><p>题意：求1-n中素数个数，n&lt;1e11;</p></blockquote><blockquote><p>解析：对于这个虽然不是积性函数，但是我们依然可以分为两块1-$\sqrt{n}$ 和$(\sqrt{n}+1 ) - n$</p><p>前者可以O(n)预处理，后者就可以利用上面第一块的$g(\sqrt{n},n)$递推</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, res[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">//欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        res[i]=res[i<span class="number">-1</span>]; <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++]=i; res[i]++;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, v[N], k, last[N], g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[n]), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, sn = <span class="built_in">sqrt</span>(n+<span class="number">0.5</span>); <span class="comment">// sqrt(n)</span></span><br><span class="line">    <span class="keyword">int</span> pos = upper_bound(prime, prime+cnt, sn) - prime; <span class="comment">// 第一个大于sqrt(n)的质数</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; i = n/(n/i+<span class="number">1</span>) ) v[++tot] = n/i; <span class="comment">// 分块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) g[i]=v[i], last[i] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tot; j; j--) &#123;</span><br><span class="line">            k = v[j]/prime[i]; <span class="keyword">if</span>(k &lt; prime[i]) <span class="keyword">break</span>; <span class="comment">// 忽略j&lt;p^2</span></span><br><span class="line">            k = k &lt; sn? k: tot - n/k + <span class="number">1</span>; <span class="comment">// 找到在v中的下标</span></span><br><span class="line">            g[j] -= g[k] - (i - last[k]); <span class="comment">// 减去g[k]中已经减过的</span></span><br><span class="line">            last[j] = i + <span class="number">1</span>; <span class="comment">// 上一次处理的是第i+1个质数(从1开始)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[sn]*<span class="number">1L</span>L + g[tot] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); <span class="keyword">return</span> solve(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洲阁筛实现起来较为复杂，现在以及被Min_25筛替代。</p><h3 id="另外一些题"><a href="#另外一些题" class="headerlink" title="另外一些题"></a>另外一些题</h3><blockquote><p>题意：定义w(n) = n的质因子个数，$g(n)=2^{w(n)}$, 求$S(n) = \sum_{i=1}^{n}g(i)\ mod\ 1e9+7$</p><p>CCPC 杭州2016J</p></blockquote><blockquote><p>$$<br>\begin{eqnarray<em>} ans&amp;=&amp;\sum_{i=1}^ng(i)\ &amp;=&amp;\sum_{i=1}^n\sum_{d|i}\mu^2(d)\ &amp;=&amp;\sum_{i=1}^n\sum_{d|i}\sum_{k^2|d}\mu(k)\ &amp;=&amp;\sum_{k=1}^n\mu(k)\sum_{k^2|d}\lfloor\frac{n}{d}\rfloor\ &amp;=&amp;\sum_{k=1}^n\mu(k)\sum_{i=1}^{\lfloor\frac{n}{k^2}\rfloor}\lfloor\frac{n}{k^2i}\rfloor\ &amp;=&amp;\sum_{k=1}^{\sqrt{n}}\mu(k)S(\lfloor\frac{n}{k^2}\rfloor) \end{eqnarray</em>}<br>$$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++] = i; mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N &amp;&amp; f[n]) <span class="keyword">return</span> f[n];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j; i &lt;= n; i = j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i); ans = (ans + (n/i)*(j-i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n &lt; N) f[n] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, ks=<span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); init();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll k = <span class="number">1</span>; k * k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mu[k]) ans = (ans + mu[k]*S(n/k/k)) % mod;</span><br><span class="line">        &#125; <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,ks++, (ans+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2018 四川省赛</p><p>题意：求$\sum_{i=1}^n\sum_{j=1}^i n \%(ij), n \le 1e11$</p></blockquote><blockquote><p>原式=$\sum_{i=1}^n\sum_{j=1}^i n - \lfloor \frac{n}{ij} \rfloor = n<em>n</em>(n+1)/2 -\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{n}{ij} \rfloor$</p><p>= $n<em>n</em>(n+1)/2 -1/2\sum_{i=1}^n\sum_{j=1}^n \lfloor \frac{n}{ij} \rfloor - 1/2\sum_{i=1}^n \lfloor \frac{n}{i^2} \rfloor $</p><p>欧拉筛预处理前n^{2/3}项后其他的暴力算，总复杂度是O(n^{2/3})</p><p>由于最后答案较大需要使用大数或者__int128</p><p>预处理的话，可以考虑$f[n] = \sum_{i=1}^i \lfloor \frac{n}{i}\rfloor i$, 那么$f[n]-f[n-1] = \sum_{i=1}^n i*( \lfloor \frac{n}{i}\rfloor - \lfloor \frac{n-1}{i}\rfloor) = \sum_{i|n}i$, 这个在欧拉筛中可以预处理,然后求一遍前缀和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">typedef</span> __int128 dll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, t[N];</span><br><span class="line">dll f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    f[<span class="number">1</span>] = t[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++]=i; f[i]=i+<span class="number">1</span>; t[i]=i;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i*prime[j]] = f[i/t[i]] + f[i]*prime[j];</span><br><span class="line">                t[i*prime[j]] = t[i] * prime[j]; <span class="keyword">break</span>;</span><br><span class="line">            &#125; f[i*prime[j]] = f[i]*(prime[j]+<span class="number">1</span>); t[i*prime[j]] = prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i] += f[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> dll <span class="title">F</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 分块求\sum_ n/i * i</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> f[n];</span><br><span class="line">    dll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans += ((dll)(j-i+<span class="number">1</span>))*(i+j)/<span class="number">2</span>*(n/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(dll x)</span></span>&#123; <span class="comment">// int128位数输出</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        dll ans = n; ans *= n; ans += ans * n; <span class="comment">// ans = n*n*(n+1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1L</span>L * i * i &lt;= n; i++) ans -= n/i/i*i*i;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">            j=n/(n/i);</span><br><span class="line">            ans -= ((dll)(j-i+<span class="number">1</span>))*(i+j)/<span class="number">2</span>*F(n/i);</span><br><span class="line">        &#125; print(ans/<span class="number">2</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rng-58-clj等式"><a href="#rng-58-clj等式" class="headerlink" title="rng_58-clj等式"></a>rng_58-clj等式</h3><p>$$<br>\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk) = \sum_{gcd(i,j)=gcd(j,k)=gcd(i,k)=1} \lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor \lfloor \frac{c}{k} \rfloor<br>$$</p><p>事实上这个等式可以扩展至任意维。</p><blockquote><p>题意：求$\sum_{i=1}^a \sum_{j=1}^b$d(ij), T, a, b &lt; 5e4;</p></blockquote><blockquote><p>原式化简为$\sum_{gcd(i,j)=1}\lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor = \sum_{g=1}^{min(a,b)} \mu(g) \sum_{i=1}^{a/g} \sum_{j=1}^{b/g}\lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor$</p><p>分块查询即可,代码略</p></blockquote><blockquote><p>题意：$\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c d(ijk)$, a,b,c &lt; 2000</p><p>化简：$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^t {\lfloor {n\over i}\rfloor}{\lfloor {m\over j}\rfloor}{\lfloor {t\over k}\rfloor} [(i,j)=1][(j,k)=1][(i,k)=1]$</p><p>=&gt;$\sum\limits_{k=1}^t {\lfloor {t\over k}\rfloor} \sum\limits_{d=1}^n \mu(d) \sum\limits_{i=1}^ {\lfloor {n\over i}\rfloor} {\lfloor {n\over i<em>d}\rfloor}[(di,k)=1] \sum\limits_{j=1}^ {\lfloor {m\over j}\rfloor} {\lfloor {m\over i</em>d}\rfloor} [(dj,k)=1]$</p><p>暴力算一下就行了(gcd可以记忆化一下)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcd __gcd</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], prime[N], a, b, c, gd[N][N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= d; i++) <span class="keyword">if</span>(gd[i][x] == <span class="number">1</span>) ans += d/i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) gd[i][j]=gd[j][i]=gcd(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c); init();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">if</span>(b &gt; c) swap(b, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">        <span class="keyword">if</span>(gcd(i, j) == <span class="number">1</span> &amp;&amp; mu[j]) ans += (a/i)*mu[j]*cal(b/j, i)*cal(c/j, i);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,ans&amp;mod), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BZOJ4176</p><p>题意：$\sum_{i=1}^n \sum_{j=1}^nd(ij), n \le 1e9$</p></blockquote><blockquote><p>化简得$= \sum_{g=1}^{n} \mu(g) \sum_{i=1}^{n/g} \sum_{j=1}^{n/g}\lfloor \frac{n}{i} \rfloor \lfloor \frac{n}{j} \rfloor$</p><p>分块查询的难调在于u(g)的前缀和，这个使用杜教筛就可以解决。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;ll mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123; <span class="comment">// 莫比乌斯前缀和</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> mu[n];</span><br><span class="line">    <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="comment">// e</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i); ans -= dfs(n/i)*(j-i+<span class="number">1</span>); <span class="comment">// 和上一题一样</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 分块求和</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans + (j-i+<span class="number">1</span>)%mod*(n/i)) % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans * ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans + (dfs(j) - dfs(i<span class="number">-1</span>) + mod)%mod*F(n/i)%mod) % mod;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h3><p>Min_25筛是一个替代洲阁晒的新产物，也是用于求解积性函数求和的问题，时间空间复杂度都比洲阁晒要优秀。</p><p>同样考虑筛质数，对1-n内所有质数求和。</p><p>设函数$S(x, j)=\sum_{i=2}^xi*[i为质数或i的最小质因子大于p_j]$ , 质数从p1开始</p><p>S(x, 0)=x*(x+1)/2 - 1; 我们要求的就是S(n, p0)</p><p>考虑转移：</p><p>$ p^2_j &gt; x, S(x, j) = S(x, j-1) \否则 S(x,j)=S(x,j-1)-f(p_j)*(S(\lfloor \frac{x}{p_j} \rfloor,j-1)-\sum_{i=1}^{j-1}f(p_i)) $</p><p>求具体积性函数和时</p><p>$G(x,j)=G(x,j+1)+\sum_{k=1}(G(\lfloor\frac{x}{p_j^k}\rfloor,j+1)-\sum_{i=1}^xf(p_i) )*f(p_j^k)+\sum_{k=2}f(p_j^k)$</p><p>能力有限，以后再学。</p></div></div><div class="copyright"><p><span>本文标题:</span><a href="/2018/08/20/acm/数论/">数论退役帖</a></p><p><span>文章作者:</span><a href="/" title="回到主页">呼哧</a></p><p><span>发布时间:</span>2018-08-20, 02:40:42</p><p><span>最后更新:</span>2018-08-20, 02:32:47</p><p><span>原始链接:</span><a class="post-url" href="/2018/08/20/acm/数论/" title="数论退役帖">http://hu-chi.github.io/2018/08/20/acm/数论/</a> <span class="copy-path" data-clipboard-text="原文: http://hu-chi.github.io/2018/08/20/acm/数论/　　作者: 呼哧" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span><script>var clipboard=new Clipboard(".copy-path")</script></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。</p></div><nav id="article-nav"><div id="article-nav-older" class="article-nav-title"><a href="/2018/08/20/acm/网络流/">网络流经典题</a></div></nav></article><div id="toc" class="toc-article"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数论退役帖"><span class="toc-number">1.</span> <span class="toc-text">数论退役帖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本知识"><span class="toc-number">1.1.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最大公因数"><span class="toc-number">1.1.1.</span> <span class="toc-text">最大公因数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用定理"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">常用定理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#素数测定"><span class="toc-number">1.1.2.</span> <span class="toc-text">素数测定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展欧几里得"><span class="toc-number">1.1.3.</span> <span class="toc-text">扩展欧几里得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#毕达哥拉斯三元组本原解"><span class="toc-number">1.1.4.</span> <span class="toc-text">毕达哥拉斯三元组本原解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#欧拉函数与欧拉定理"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">欧拉函数与欧拉定理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉筛"><span class="toc-number">1.1.5.</span> <span class="toc-text">欧拉筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉例题"><span class="toc-number">1.1.6.</span> <span class="toc-text">欧拉例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二次筛法-POJ-2689"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">二次筛法 POJ - 2689</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HDU-3939-直角三角形个数"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">HDU - 3939 直角三角形个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆元"><span class="toc-number">1.1.7.</span> <span class="toc-text">逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等比数列求和"><span class="toc-number">1.1.8.</span> <span class="toc-text">等比数列求和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POJ-3233-等比矩阵求和"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">POJ - 3233 等比矩阵求和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合数计算"><span class="toc-number">1.1.9.</span> <span class="toc-text">组合数计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中国剩余定理-CRT"><span class="toc-number">1.1.10.</span> <span class="toc-text">中国剩余定理(CRT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反素数"><span class="toc-number">1.1.11.</span> <span class="toc-text">反素数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求最小的数使其因数为n-CF27E"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">求最小的数使其因数为n CF27E</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#求1-n因数个数最大的数-URAL-1748"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">求1-n因数个数最大的数 URAL 1748</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HDU-4542"><span class="toc-number">1.1.11.3.</span> <span class="toc-text">HDU - 4542</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指数循环节"><span class="toc-number">1.2.</span> <span class="toc-text">指数循环节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#积性函数"><span class="toc-number">1.3.</span> <span class="toc-text">积性函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#积性函数的定义"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">积性函数的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的积性函数"><span class="toc-number">1.3.1.</span> <span class="toc-text">常见的积性函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个常用的公式"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">两个常用的公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#积性函数性质"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">积性函数性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分块技巧"><span class="toc-number">1.3.2.</span> <span class="toc-text">分块技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迪利克雷卷积"><span class="toc-number">1.3.3.</span> <span class="toc-text">迪利克雷卷积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#积性函数例题-HDU-5528"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">积性函数例题 HDU - 5528</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#积性函数习题-757E"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">积性函数习题 757E</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#莫比乌斯反演"><span class="toc-number">1.3.4.</span> <span class="toc-text">莫比乌斯反演</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#经典例题-求互质的数对数-HDU-1695"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">经典例题-求互质的数对数 HDU - 1695</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD表中的质数"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">GCD表中的质数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#杜教筛"><span class="toc-number">1.3.5.</span> <span class="toc-text">杜教筛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#欧拉函数前缀和-51nod-1239"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">欧拉函数前缀和 51nod 1239</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#莫比乌斯函数前缀和"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">莫比乌斯函数前缀和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extended-Eratosthenes-Sieve洲阁筛"><span class="toc-number">1.3.6.</span> <span class="toc-text">Extended Eratosthenes Sieve洲阁筛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#素数个数"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">素数个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#另外一些题"><span class="toc-number">1.3.7.</span> <span class="toc-text">另外一些题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rng-58-clj等式"><span class="toc-number">1.3.8.</span> <span class="toc-text">rng_58-clj等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Min-25筛"><span class="toc-number">1.3.9.</span> <span class="toc-text">Min_25筛</span></a></li></ol></li></ol></div><style>.left-col .switch-area,.left-col .switch-btn{display:none}.toc-level-3 i,.toc-level-3 ol{display:none!important}</style><input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录"><script>yiliaConfig.toc=["隐藏目录","显示目录",!0]</script><div class="share"><div class="bdsharebuttonbox"><a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a> <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a> <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a> <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a> <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a> <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a> <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></a></div><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"数论退役帖　| Play with huchi　",bdMini:"2",bdMiniList:!1,bdPic:"",bdStyle:"0",bdSize:"24"},share:{}},document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)</script></div><div class="scroll" id="post-nav-button"><a href="/" title="回到主页"><i class="fa fa-home"></i></a> <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a> <a href="/2018/08/20/acm/网络流/" title="下一篇: 网络流经典题"><i class="fa fa-angle-right"></i></a></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/acm/数论/">数论退役帖</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/acm/网络流/">网络流经典题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/acm/hash/">hash在ACM种的应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/hadoop/wordcount/">Hadoop的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/hadoop/Linux安装hadoop/">Hadoop的安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/19/machineLearning/Lesson1/">机器学习初识</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/29/随笔集/2017年末总结/">2017年末总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/设计模式/python设计模式(4)/">python设计模式(四)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/设计模式/python设计模式(3)/">python设计模式(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/19/设计模式/python设计模式(2)/">python设计模式(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/24/设计模式/python设计模式(1)/">python设计模式(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/12/fluentPython/fluent_python5/">fluent python (五)一等函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/12/fluentPython/fluent_python2/">fluent python (二)python数据模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/acm/循环节/">指数循环节</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/fluentPython/fluent_python1/">fluent python (一)python数据模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/08/acm/01分数规划/">01分数规划</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/acm/大数模板/">大数模版</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/acm/堆排序/">堆排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/acm/容斥原理/">容斥原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/acm/三分与退火模拟/">三分与模拟退火</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/acm/Acdreamer博客数论学习(2)/">Acdreamer博客数论学习(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/04/acm/从dp的全世界路过(1)/">从dp的全世界路过(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/acm/低等数论1/">数论知识点摘要1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/19/acm/Acdreamer博客数论学习(1)/">Acdreamer博客数论学习(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/19/acm/高斯消元/">高斯消元</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/acm/数论基础专题整理(1)/">数论专题整理(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/12/acm/数位dp/">数位dp专题整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/读书笔记/拆掉思维里的墙(下)/">拆掉思维里的墙(下)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/07/acm/7-7acm整理笔记/">acm7-7总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/读书笔记/拆掉思维里的墙(上)/">拆掉思维里的墙(上)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/28/脚本/Script_ascii/">script： translate picture into ascii.text</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/27/读书笔记/哈佛的6堂独立思考课/">哈佛的6堂独立思考课</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/网页学习/djangoStart01/">Django_GO01</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Linux-计算机基础认识/">Linux_计算机基础认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/10/python网络编程-init/">python网络编程.init()</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/07/随笔集/新的开始/">新的开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/07/网页学习/测试jsDOM笔记/">测试jsDOM入门笔记</a></li></ul><script></script></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"><i class="fa fa-copyright"></i> 2018 呼哧</div><div class="footer-right"><a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a> Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i></div></div><div class="visit"><span id="busuanzi_container_site_pv" style="display:none"><span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span> </span></span><span>| </span><span id="busuanzi_container_page_pv" style="display:none"><span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span></span></span></div></div></footer></div><script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script><script>$(document).ready(function(){if(-1<window.navigator.userAgent.indexOf("iPad")||"none"===$(".left-col").css("display")){var a=["#9db3f4","#414141","#e5a859","#f5dfc6","#c084a0","#847e72","#cd8390","#996731"],c=Math.ceil(Math.random()*(a.length-1));$("body").css({"background-color":a[c],"background-size":"cover"})}else{var e="url(/background/bg-x.jpg)".replace(/x/gi,Math.ceil(5*Math.random()));$("body").css({background:e,"background-attachment":"fixed","background-size":"cover"})}})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});</script><script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="scroll" id="scroll"><a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a> <a href="#comments" onclick="load$hide()" title="查看评论"><i class="fa fa-comments-o"></i></a> <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a></div><script>var oOpenInNew={archives:".archive-article-title",miniArchives:"a.post-list-link",friends:"#js-friends a",socail:".social a"};for(var x in oOpenInNew)$(oOpenInNew[x]).attr("target","_blank")</script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body>