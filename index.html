<!DOCTYPE html><html lang="zh-Hans"><head><!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]--><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="呼哧"><meta property="og:type" content="website"><meta property="og:title" content="Play with huchi"><meta property="og:url" content="http://hu-chi.github.io/index.html"><meta property="og:site_name" content="Play with huchi"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Play with huchi"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="alternate" href="/atom.xml" title="Play with huchi" type="application/atom+xml"><link rel="shortcut icon" href="/img/huchi.jpg"><link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet"><link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"><style>.article{opacity:0}</style><link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"><title>Play with huchi</title><script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script>var yiliaConfig={fancybox:!0,animate:!0,isHome:!0,isPost:!1,isArchive:!1,isTag:!1,isCategory:!1,fancybox_js:"//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",scrollreveal:"//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",search:!0}</script><script>yiliaConfig.jquery_ui=[!0,"//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js","//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"]</script><script>yiliaConfig.rootUrl="/"</script></head></html><body><div id="container"><div class="left-col"><div class="overlay"></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/huchi.jpg" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/">呼哧</a></h1></hgroup><p class="header-subtitle">看遍南海风云卷，最恨难赴故人约。</p><form id="search-form"><input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search-result"></div><p class="no-result">No results found <i class="fa fa-spinner fa-pulse"></i></p><div id="switch-btn" class="switch-btn"><div class="icon"><div class="icon-ctn"><div class="icon-wrap icon-house" data-idx="0"><div class="birdhouse"></div><div class="birdhouse_holes"></div></div><div class="icon-wrap icon-ribbon hide" data-idx="1"><div class="ribbon"></div></div><div class="icon-wrap icon-link hide" data-idx="2"><div class="loopback_l"></div><div class="loopback_r"></div></div><div class="icon-wrap icon-me hide" data-idx="3"><div class="user"></div><div class="shoulder"></div></div></div></div><div class="tips-box hide"><div class="tips-arrow"></div><ul class="tips-inner"><li>菜单</li><li>标签</li><li>友情链接</li><li>关于我</li></ul></div></div><div id="switch-area" class="switch-area"><div class="switch-wrap"><section class="switch-part switch-part1"><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/随笔">随笔</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" href="/779197837@qq.com" title="Email"></a> <a class="fa GitHub" href="#" title="GitHub"></a> <a class="fa RSS" href="/atom.xml" title="RSS"></a></ul></nav></section><section class="switch-part switch-part2"><div class="widget tagcloud" id="js-tagcloud"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/">acm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/script/">script</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/starts/">starts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端设计/">前端设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂书/">杂书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div></section><section class="switch-part switch-part3"><div id="js-friends"><a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a> <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a> <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a></div></section><section class="switch-part switch-part4"><div id="js-aboutme">专注于前端</div></section></div></div></header></div></div><div class="mid-col"><nav id="mobile-nav"><div class="overlay"><div class="slider-trigger"></div><h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">呼哧</a></h1></div><div class="intrude-less"><header id="header" class="inner"><a href="/" class="profilepic"><img src="/img/huchi.jpg" class="animated zoomIn"></a><hgroup><h1 class="header-author"><a href="/" title="回到主页">呼哧</a></h1></hgroup><p class="header-subtitle">看遍南海风云卷，最恨难赴故人约。</p><nav class="header-menu"><ul><li><a href="/">主页</a></li><li><a href="/archives/">所有文章</a></li><li><a href="/tags/随笔">随笔</a></li><li><a href="/tags/">标签云</a></li><li><a href="/about/">关于我</a></li><div class="clearfix"></div></ul></nav><nav class="header-nav"><ul class="social"><a class="fa Email" target="_blank" href="/779197837@qq.com" title="Email"></a> <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a> <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a></ul></nav></header></div><link class="menu-list" tags="标签" friends="友情链接" about="关于我"></nav><div class="body-wrap"><article id="article-acm/数论" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/20/acm/数论/" class="article-date"><time datetime="2018-08-19T18:40:42.000Z" itemprop="datePublished">2018-08-20</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/08/20/acm/数论/">数论退役帖</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="数论退役帖"><a href="#数论退役帖" class="headerlink" title="数论退役帖"></a>数论退役帖</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h3><p>找寻a,b的最大公因数, 利用辗转相除法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者直接使用自带函数 __gcd(a, b)</span></span><br></pre></td></tr></table></figure><h4 id="常用定理"><a href="#常用定理" class="headerlink" title="常用定理"></a>常用定理</h4><ol><li>$ gcd(a^n - 1, a^m - 1) = a^{gcd(n, m)} -1$</li><li>扩展 $a&gt;b, gcd(a, b)=1 时 gcd(a^m-b^m, a^n- b^n) = a^{gcd(m, n)} - b^{gcd(m, n)}$</li><li>$G = gcd(C^1_n, C^2_n, …, C^{n-1}_n)$<ul><li>n为质数时G=n</li><li>n有多个质因子时，G=1</li><li>n有一个质因子p，G=p</li></ul></li><li>$F_n 为斐波那契额数列， gcd(F_n, F_m) = F_{gcd(n, m)}$</li><li>给定两个互素的正整数A,B， 那么他们组合的数C=p*A+q*B&gt;0， C最大为AB-A-B,不能组合的个数为$\frac{(A-1)*(B-1)}{2}$</li><li>$(n+1) lcm(C_n^0, C_n^1, .., C^n_n) = lcm(1, 2, 3, .. , n+1)$</li><li>对于质数p,$(x+y+…+w)^p \%p == (x^p + y^p + … + w^p) % p$</li></ol><h3 id="素数测定"><a href="#素数测定" class="headerlink" title="素数测定"></a>素数测定</h3><p>素数测定常用Miller-Rabin素数测试，是基于费马小定理 $a^p \equiv a(mod \ p ) p为质数$</p><p>反过来，如果满足该式子，p大多数为质数</p><p>Miller-Rabin 素数测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Times = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">multi</span><span class="params">(ll a, ll b ,ll m)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>; a%=m;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = (ans+a)%m;</span><br><span class="line">        a = (a+a)%m; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quick_mod</span><span class="params">(ll a, ll b, ll m)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= m;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = multi(ans, a, m);</span><br><span class="line">        a = multi(a,a,m); b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>((n&lt;<span class="number">2</span>) || !(n&amp;<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((m&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        k++; m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Times; i++)&#123;</span><br><span class="line">        ll a = rand()%(n<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        ll x = quick_mod(a,m,n);</span><br><span class="line">        ll y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            y = multi(x,x,n);</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x!=<span class="number">1</span> &amp;&amp; x!= n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x = y;</span><br><span class="line">        &#125; <span class="keyword">if</span>(y!=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>51Nod 质数检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		BigInteger x;</span><br><span class="line">		x=cin.nextBigInteger();</span><br><span class="line">		<span class="keyword">if</span>(x.isProbablePrime(<span class="number">1</span>)) System.out.println(<span class="string">"Yes"</span>); <span class="comment">// java 自带Miller_Rabin</span></span><br><span class="line">		<span class="keyword">else</span> System.out.println(<span class="string">"No"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>对于二元一次方程 ax+by=gcd(a, b) 利用扩展欧几里得可以求得一组可行解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d=a,x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e_gcd(b,a%b,d,y,x);</span><br><span class="line">        y -= (a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a&gt;b时x为正数。可以令y=(y%a + a) % a 把y变成正数，再利用原始计算x</p><h3 id="毕达哥拉斯三元组本原解"><a href="#毕达哥拉斯三元组本原解" class="headerlink" title="毕达哥拉斯三元组本原解"></a>毕达哥拉斯三元组本原解</h3><p>对于$x^2 + y ^2 = z^2$ 我们只考虑本原解，即x,y,z互质。</p><p>这样的话，我们不妨假设x为偶数，y，z为奇数，那么就存在互质的数n,m</p><p>而且n,m一奇一偶且m&gt;n, 有$x=2 <em>m </em>n, y = m^2 - n ^ 2 , z= m^2 + n^2$</p><p><strong>POJ - 1305</strong></p><p>题意： 给一个正整数n求解，求解n的范围内gcd值为1的勾股数和不是勾股数的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> biao[N], n;</span><br><span class="line"><span class="keyword">bool</span> flag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(gcd(i,j)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;<span class="number">1</span>)&amp;&amp;(j&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i*i+j*j&lt;N)biao[i*i+j*j]++; <span class="comment">// 标记i^2+j^2即斜边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) biao[i]+=biao[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span> flag);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gcd(i,j)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((i&amp;<span class="number">1</span>)&amp;&amp;(j&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k*(i*i+j*j)&lt;=n; k++)&#123; <span class="comment">// 枚举斜边长并标记</span></span><br><span class="line">                    flag[<span class="number">2</span>*i*j*k]=flag[k*(i*i-j*j)]=flag[k*(i*i+j*j)]=<span class="number">1</span>; <span class="comment">// 标记使用过的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span>(flag[i])ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,biao[n],n-ans); </span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉函数与欧拉定理"><a href="#欧拉函数与欧拉定理" class="headerlink" title="欧拉函数与欧拉定理"></a>欧拉函数与欧拉定理</h4><p>我们定义欧拉函数$\phi (n) = 小于n且与n互质的数， \phi(1) = 1, \phi(2) = 1$</p><ol><li>m与n互素， $\phi(mn)=\phi(n)*\phi(m)$</li><li>$n = p_1^{a_1} p_2^{a_2} p_3^{a_3}… p_n^{a_n}, \phi(n) = n<em>(1 - \frac{1}{p_1})</em>(1 - \frac{1}{p_2})<em>(1 - \frac{1}{p_3})</em>…*(1 - \frac{1}{p_n}) $</li><li>$\sum_{d|n} \phi(d) = n$ 即n的因子的欧拉函数之和为n</li><li>a,m互质时, $x \equiv va^{\phi(m) - 1} 等价于 ax \equiv b(mod \ m)$ 事实上就是指数循环节</li></ol><p>容斥计算欧拉函数，复杂度$O(\sqrt{n})$：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans - ans/i; <span class="comment">// 减去i的倍数</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>)ans = ans-ans/n; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h3><p>欧拉筛是可以做到O(n) 预处理1-n之间所有的质因数， 通过对其修改，我们也能预处理出欧拉函数和莫比乌斯函数以及因数个数。一般欧拉函数不需要修改，可以作为模板.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">// mu为莫比乌斯函数，d为因数个数， phi为欧拉函数， cnt为1-n质数个数</span></span><br><span class="line"><span class="keyword">int</span> mu[N],prime[N],d[N],ti[N],phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = d[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime[cnt++] = i; mu[i] = <span class="number">-1</span>;</span><br><span class="line">            d[i] = <span class="number">2</span>; ti[i] = <span class="number">1</span>; phi[i] = i<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N)<span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                ti[i*prime[j]] = ti[i] + <span class="number">1</span>;</span><br><span class="line">                d[i*prime[j]] = d[i]/(ti[i]+<span class="number">1</span>)*(ti[i]+<span class="number">2</span>);</span><br><span class="line">                phi[i*prime[j]]=phi[i]*prime[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; mu[i*prime[j]] = -mu[i];</span><br><span class="line">            d[i*prime[j]] = d[i]*<span class="number">2</span>;</span><br><span class="line">            ti[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            phi[i*prime[j]] = phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉例题"><a href="#欧拉例题" class="headerlink" title="欧拉例题"></a>欧拉例题</h3><h4 id="二次筛法-POJ-2689"><a href="#二次筛法-POJ-2689" class="headerlink" title="二次筛法 POJ - 2689"></a>二次筛法 <a href="https://vjudge.net/problem/10258/origin" target="_blank" rel="noopener">POJ - 2689</a></h4><blockquote><p>题意: 给出一个区间[L,U]，求给定区间内的质数距离最小的一对和质数距离最大的一对。U&lt;=1e9, U-L &lt;= 1e6</p><p>方法: 预处理$\sqrt{1e9} $ 的质数, 然后对[L, U] 区间内去晒(即标记)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> judge[<span class="number">21</span>*N], vis[N];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); uint u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v))&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">1</span>)u=<span class="number">2</span>; <span class="comment">// 1不是质数</span></span><br><span class="line">        <span class="built_in">memset</span>(judge,<span class="number">0</span>,<span class="keyword">sizeof</span> judge);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i] &lt;= v; i++)&#123;</span><br><span class="line">            uint j=((u<span class="number">-1</span>)/prime[i]+<span class="number">1</span>)*prime[i]; <span class="comment">// 第一个&gt;=u的prime[i]的倍数</span></span><br><span class="line">            <span class="keyword">if</span>(j == prime[i]) j += prime[i]; <span class="comment">// j为质数跳过</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt;= v; j+=prime[i]) judge[j-u]=<span class="number">1</span>; <span class="comment">// 晒去prime[i]的倍数</span></span><br><span class="line">        &#125; <span class="keyword">int</span> st,stlen=N,ed,edlen=<span class="number">0</span>,cot=<span class="number">0</span>,len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= v-u; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!judge[i])&#123;  <span class="comment">// 即u+i为质数</span></span><br><span class="line">                <span class="keyword">if</span>(len &amp;&amp; len&lt;stlen)&#123;</span><br><span class="line">                    st = i-len; stlen = len; <span class="comment">//更新最近的质数对</span></span><br><span class="line">                &#125; <span class="keyword">if</span>(len &amp;&amp; len&gt;=edlen)&#123;</span><br><span class="line">                    ed = i-len; edlen = len; <span class="comment">//更新最远的质数对</span></span><br><span class="line">                &#125; cot++; len = <span class="number">0</span>; <span class="comment">// 统计区间质数个数</span></span><br><span class="line">            &#125; len ++ ;</span><br><span class="line">        &#125; <span class="keyword">if</span>(cot&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"%d,%d are closest, %d,%d are most distant.\n"</span>,u+st,u+st+stlen,u+ed,u+ed+edlen);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"There are no adjacent primes."</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-3939-直角三角形个数"><a href="#HDU-3939-直角三角形个数" class="headerlink" title="HDU - 3939 直角三角形个数"></a><a href="https://vjudge.net/problem/22080/origin" target="_blank" rel="noopener">HDU - 3939</a> 直角三角形个数</h4><blockquote><p>题意: 求a,b,c&lt;=L的三角形个数且满足a&lt;b&lt;c.abc互质. L &lt; 1e12</p></blockquote><blockquote><p>利用三元组本原解枚举n,m实现sqrt(1e12), 容斥去重</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">10</span>], phi[N], check[<span class="number">40</span>], cnt, num;</span><br><span class="line">ll ans, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;prime[cnt++]=i;phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123; phi[i*prime[j]]=phi[i]*prime[j];<span class="keyword">break</span>;&#125;</span><br><span class="line">            phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime_check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!vis[n])&#123; check[num++]=n; <span class="keyword">return</span> ; &#125; <span class="comment">//n 为质数直接返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; prime[i]*prime[i] &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            check[num++]=prime[i];</span><br><span class="line">            <span class="keyword">while</span>(n%prime[i]==<span class="number">0</span>) n/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) check[num++]=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容斥原理计算无关的数fun(j)=j-(j/c1+j/c2+j/c3)+(j/(c1*c2)+j/(c1*c3)+j/(c2*c3))-(j/(c1*c2*c3))。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==num)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&amp;<span class="number">1</span>) ans -= n/s;</span><br><span class="line">        <span class="keyword">else</span> ans+= n/s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; dfs(k+<span class="number">1</span>, r, s, n);</span><br><span class="line">    dfs(k+<span class="number">1</span>, r+<span class="number">1</span>, s*check[k], n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;L);</span><br><span class="line">        <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*L + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 枚举m ， n&lt;m 只要计算有多少符合n就行</span></span><br><span class="line">            <span class="keyword">int</span> p = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(L - (ll)i*i + <span class="number">0.5</span>); <span class="comment">// n的上界</span></span><br><span class="line">            <span class="keyword">if</span> ( i&lt;=p ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    prime_check(i); dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> ans += phi[i]; <span class="comment">// 对于偶数，与其互质的数都为奇数可以直接</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// i&gt;p时，j所取的范围在[1,p]</span></span><br><span class="line">                prime_check(i);</span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,p&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><p>对于$am \equiv 1 (mod \ m)$, 这个同余方程中最小的x正整数解叫做a模m的逆元;</p><p>也就是说$\frac{1}{a} \equiv x (mod \ m)$</p><p>由费马小定理得a对于模数mod为质数的逆元$a^{mod - 2}$可以用快速幂log求得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= mod;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a*a % mod;</span><br><span class="line">        k &gt;&gt; = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qp(a%mod, mod<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理逆元:</p><p>我们可预处理1-n的逆元是O(n)的复杂度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i) </span><br><span class="line">    inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br></pre></td></tr></table></figure><p>预处理n! 的逆元inv</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ll fac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[N<span class="number">-1</span>] = qp(fac[N<span class="number">-1</span>], mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-2</span>; i; i--) inv[i]=(i+<span class="number">1</span>)*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等比数列求和"><a href="#等比数列求和" class="headerlink" title="等比数列求和"></a>等比数列求和</h3><p>$S_n = (a + a^2 + .. + a^n) mod M$</p><p>如果使用高中的公式那么就是a = 1 时$s_n = n \mod \ M$, 如果a!=1, $S_n = \frac{a - a ^{n+1}}{1 - a}$</p><p>这里还有一种方法: 二分</p><p>对于n%2 == 0 $S_n = (1 + a ^{\frac{n}{2}}) S_{\frac{n}{2}}$</p><p>否则 $S_n = (1 + a^{\frac{n+1}{2}})S_{\frac{n+1}{2}} + a^{\frac{n+1}{2}}$</p><h4 id="POJ-3233-等比矩阵求和"><a href="#POJ-3233-等比矩阵求和" class="headerlink" title="POJ - 3233 等比矩阵求和"></a>POJ - 3233 等比矩阵求和</h4><p>如果利用上面的递推式子就可以解决矩阵的i次求和问题.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line">    Matrix()&#123; <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp); &#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; mp[i][i] = v; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123; <span class="keyword">if</span>(a.mp[i][k])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="keyword">if</span>(b.mp[k][j])</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][k]*b.mp[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">pls</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a.mp[i][j] = (a.mp[i][j]+b.mp[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">powmul</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Matrix c = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)c = multi(c,a);</span><br><span class="line">        a = multi(a,a); k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">S</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">    Matrix temp = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        Matrix temp2 = powmul(a,(k+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> pls(multi(pls(temp, temp2), S(a,(k<span class="number">-1</span>)/<span class="number">2</span>)), temp2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Matrix temp2 = powmul(a,k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> multi(pls(temp, temp2), S(a,k/<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;mod))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a.mp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; a = S(a,k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,a.mp[i][j]);</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a.mp[i][n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个复杂度时有点高的,还可以构造矩阵利用矩阵快速幂一步到位。</p><p>我们要求的矩阵和为$S_n$</p><p>那么 $$ \begin{bmatrix} S_n \ A^n \end{bmatrix} = \begin{bmatrix}1 &amp; A \ 0 &amp; A \end{bmatrix} \begin{bmatrix} S_{n-1} \ A^{n-1} \end{bmatrix} $$</p><p>那么复杂度为O(60^3 * log k)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line">    Matrix()&#123; <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp); &#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; mp[i][i] = v; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123; <span class="keyword">if</span>(a.mp[i][k])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;<span class="keyword">if</span>(b.mp[k][j])</span><br><span class="line">                c.mp[i][j] = (c.mp[i][j] + a.mp[i][k]*b.mp[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">pls</span><span class="params">(Matrix a, Matrix b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a.mp[i][j] = (a.mp[i][j]+b.mp[i][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">powmul</span><span class="params">(Matrix a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Matrix c = Matrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)c = multi(c,a);</span><br><span class="line">        a = multi(a,a); k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;mod))&#123;</span><br><span class="line">        Matrix a; <span class="keyword">int</span> g;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a.mp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;g);</span><br><span class="line">                a.mp[i][j+n]=a.mp[i+n][j+n]=g%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; n *= <span class="number">2</span>; a = powmul(a, k); n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>+n; j &lt; n*<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,(a.mp[i][j])%mod);</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (a.mp[i][<span class="number">2</span>*n])%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h3><p>从n个物品中选取k个物品有$C_n^{k}$ 种方法。</p><p>组合数表预处理 mod任意:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理阶乘， mod只能为质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[N<span class="number">-1</span>] = qp(fac[N<span class="number">-1</span>], mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-2</span>; i; i--) inv[i]=(i+<span class="number">1</span>)*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod; &#125;</span><br></pre></td></tr></table></figure><p>Lucas 模数必须为小质数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n%p,m%p)*Lucas(n/p,m/p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h3><p>有n组同余方程<br>$$<br>x \equiv a_1 (mod \ m_1) \ x \equiv a_2 (mod \ m_2) \ x \equiv a_3 (mod \ m_3) \ … \ x \equiv a_n (mod \ m_n) \<br>$$<br>利用CRT既可以解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d = a; x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    e_gcd(b, a%b, d, y, x);</span><br><span class="line">    y -= x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中国剩余定理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)M *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,d;</span><br><span class="line">        <span class="keyword">int</span> Mi = M/m[i];</span><br><span class="line">        e_gcd(Mi, m[i], d, x, y);</span><br><span class="line">        ans = (ans + Mi*x*a[i])%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans+= M;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通中国剩余定理要求的$m_1,m_2,…,m_k$互素.但如果发生不互素时,需要采用两两合并.</p><h3 id="反素数"><a href="#反素数" class="headerlink" title="反素数"></a>反素数</h3><p>f(n)为n的因数个数，对于0&lt;i&lt;n，f(i) &lt; f(n), 则称n为反素数。</p><p>反素数一般满足质因数的幂次随着质因数的大小增大而减小</p><p>即 $若 n = 2^{t_1}3^{t_2}, 则必有t_1 \ge t_2$</p><h4 id="求最小的数使其因数为n-CF27E"><a href="#求最小的数使其因数为n-CF27E" class="headerlink" title="求最小的数使其因数为n  CF27E"></a>求最小的数使其因数为n CF27E</h4><p>n&lt;=1000，我们贪心的认为其质因数不会超过前50个质数，而且幂次不会超过63。</p><p>dfs暴力枚举加剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ll tmp, <span class="keyword">int</span> num)</span></span>&#123;  <span class="comment">//depth 为第几个质数, tmp为当前的值，um为因数个数</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; n || depth&gt;=cnt)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(num == n &amp;&amp; ans &gt; tmp)&#123;</span><br><span class="line">        ans = tmp; <span class="keyword">return</span>; <span class="comment">// 满足的情况下更新</span></span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i &lt;= <span class="number">63</span>; i++)&#123; <span class="comment">// 枚举幂次， 事实上可以记录上一次的幂次来优化剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(ans/prime[depth]&lt;tmp || num*(i+<span class="number">1</span>)&gt;n) <span class="keyword">return</span>; <span class="comment">// 用除法防止溢出</span></span><br><span class="line">        dfs(depth+<span class="number">1</span>, tmp*=prime[depth], num*(i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求1-n因数个数最大的数-URAL-1748"><a href="#求1-n因数个数最大的数-URAL-1748" class="headerlink" title="求1-n因数个数最大的数 URAL 1748"></a>求1-n因数个数最大的数 URAL 1748</h4><p>同样使用dfs暴力枚举</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, ll ansa, <span class="keyword">int</span> ansb, <span class="keyword">int</span> limit)</span></span>&#123; <span class="comment">//ansa为值, ansb为因数个数</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt;= tot || ansa &gt; n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ansb &gt; b|| ((ansb == b) &amp;&amp; a&gt;ansa))&#123;</span><br><span class="line">        a = ansa; b = ansb;</span><br><span class="line">    &#125; <span class="keyword">for</span>(ll i = <span class="number">1</span>; depth &lt; tot &amp;&amp; i &lt;= limit; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansa &gt; n/prime[depth])<span class="keyword">break</span>;</span><br><span class="line">        dfs(depth+<span class="number">1</span>, ansa*=prime[depth], ansb*(i+<span class="number">1</span>), i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HDU-4542"><a href="#HDU-4542" class="headerlink" title="HDU - 4542"></a><a href="https://vjudge.net/problem/37955/origin" target="_blank" rel="noopener">HDU - 4542</a></h4><blockquote><p>题意： X mod ai = bi 对于ai在区间 [1, X] 范围内每个值取一次时，有K个ai使bi等于0 。</p><p>告诉你有K个ai使得(不使得) bi等于0</p><p>找最小的X</p></blockquote><blockquote><p>解析：K个相等的时候我们去dfs暴力枚举，K个不相等的话这个数一定不大，先预处理</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) d[i] = i; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;N; j+=i) d[j]--; <span class="comment">// 容斥减去因子个数</span></span><br><span class="line">        <span class="keyword">if</span>(!d[d[i]]) d[d[i]] = i; <span class="comment">// 更新因子个数为d[i]位置的数为i， 节约了空间,这样也保是最小的</span></span><br><span class="line">        d[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> dfs(<span class="keyword">int</span> depth, ll ansa, <span class="keyword">int</span> ansb, <span class="keyword">int</span> limit)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ansb &gt; k || depth &gt; <span class="number">16</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(ansb == k &amp;&amp; ansa&lt;ans)&#123;</span><br><span class="line">        ans = ansa; <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ansa &gt; pos/prime[depth] || ansb*(i+<span class="number">1</span>)&gt;k) <span class="keyword">break</span>;</span><br><span class="line">        ansa*=prime[depth];</span><br><span class="line">        <span class="keyword">if</span>(k%(ansb*(i+<span class="number">1</span>))==<span class="number">0</span>) dfs(depth+<span class="number">1</span>, ansa, ansb*(i+<span class="number">1</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> T,t=<span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(t++&lt;T) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;type,&amp;k); ans = flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(type) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[k]) <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,t,d[k]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: Illegal\n"</span>,t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ~<span class="number">0u</span>ll; dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">63</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; inf) <span class="built_in">printf</span>(<span class="string">"Case %d: INF\n"</span>,t);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>,t,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数循环节"><a href="#指数循环节" class="headerlink" title="指数循环节"></a>指数循环节</h2><p>$$a^b \equiv a^{b \% \phi(c)+\phi(c)}(mod \ c),b&gt;\phi(c) $$</p><p>例题 <a href="https://vjudge.net/problem/HDU-4335" target="_blank" rel="noopener">C - What is N?</a></p><p>这里求$$n^{n!} \equiv b(mod \ p)$$有多少个成立的n，对于指数%phi(p)为0后的数，是存在循环节的。只要记录一下一次循环的个数p，最后多余的部分去跑一下记忆化的就知道有多少组了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            res = res - res/i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res - res/n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">quickmod</span><span class="params">(ll a, ll b, ll c)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%c;</span><br><span class="line">        a = a*a%c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll b, p, m, fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>,T;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(t++&lt;T)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64u%I64u%I64u"</span>, &amp;b, &amp;p, &amp;m); <span class="built_in">printf</span>(<span class="string">"Case #%d: "</span>,t);</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">18446744073709551615u</span>ll) <span class="built_in">printf</span>(<span class="string">"18446744073709551616\n"</span>); <span class="comment">// 防止溢出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,m+<span class="number">1</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ll i = <span class="number">0</span>, ans = <span class="number">0</span>, fac = <span class="number">1</span>;</span><br><span class="line">            ll phic = phi(p);</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m &amp;&amp; fac&lt;=phic; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(quickmod(i, fac, p) == b) ans ++; <span class="comment">// 计算n! &lt;= phi(p)的个数</span></span><br><span class="line">                fac *= i+<span class="number">1</span>;</span><br><span class="line">            &#125; fac = fac%phic; <span class="comment">//指数循环节公式</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt;= m &amp;&amp; fac; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(quickmod(i, fac + phic, p) == b) ans++;</span><br><span class="line">                fac = (fac*(i+<span class="number">1</span>))%phic;</span><br><span class="line">            &#125; <span class="comment">// 至多跑一个循环或者不超过M</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= m)&#123;</span><br><span class="line">                ll cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++)&#123;</span><br><span class="line">                    fa[j] = quickmod(i+j, phic, p); <span class="comment">// 记忆化p长度的循环</span></span><br><span class="line">                    <span class="keyword">if</span>(fa[j] == b) cnt ++;</span><br><span class="line">                &#125;</span><br><span class="line">                ll idx = (m-i+<span class="number">1</span>)/p; <span class="comment">// 循环个数</span></span><br><span class="line">                ans += cnt * idx;   <span class="comment">// 循环的种数</span></span><br><span class="line">                ll remain = (m-i+<span class="number">1</span>)%p; <span class="comment">// 不足一个循环的数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; remain; j++) <span class="keyword">if</span>(fa[j] == b) ans ++ ;</span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%I64u\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>牛客练习赛 22E</strong></p><blockquote><p>题意：给一个长为n的序列，m次操作，每次操作：</p><p>1.区间<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D" alt="img">加<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378748233_equation?tex=x" alt="img"></p><p>2.对于区间<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378738770_equation?tex=%5Bl%2Cr%5D" alt="img">，查询<img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378680406_equation?tex=a%5Bl%5D%5E%7Ba%5Bl%2B1%5D%5E%7Ba%5Bl%2B2%5D......%7D%7D" alt="img"><img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378709031_equation?tex=mod" alt="img"> <img src="https://uploadfiles.nowcoder.com/files/20180712/304073_1531378718196_equation?tex=p" alt="img">，一直到$a_r$</p><p>请注意每次的模数不同。</p></blockquote><p>区间加值我们可以考虑使用线段树lazy标记，查询就直接使用指数循环节公式倒过来计算就行了。</p><p>这道题因为数据太多，用文件读入才能过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e7</span>+<span class="number">9</span>;</span><br><span class="line">ll val[N];</span><br><span class="line"><span class="keyword">bool</span> judge[M];</span><br><span class="line"><span class="keyword">int</span> prime[M],p[M],mod[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastIO&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUT_SIZE 100000</span></span><br><span class="line">  <span class="comment">//fread-&gt;read</span></span><br><span class="line">  <span class="keyword">bool</span> IOerror=<span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">      p1=buf; pend=buf+fread(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdin</span>);</span><br><span class="line">      <span class="keyword">if</span> (pend==p1)&#123;IOerror=<span class="number">1</span>;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">      <span class="comment">//&#123;printf("IO error!\n");system("pause");for (;;);exit(0);&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *p1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;<span class="keyword">return</span> ch==<span class="string">' '</span>||ch==<span class="string">'\n'</span>||ch==<span class="string">'\r'</span>||ch==<span class="string">'\t'</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ll &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">double</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> sign=<span class="number">0</span>; <span class="keyword">char</span> ch=nc(); x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'-'</span>)sign=<span class="number">1</span>,ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">'.'</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> tmp=<span class="number">1</span>; ch=nc();</span><br><span class="line">      <span class="keyword">for</span> (;ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>;ch=nc())tmp/=<span class="number">10.0</span>,x+=tmp*(ch-<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign)x=-x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=nc();</span><br><span class="line">    <span class="keyword">for</span> (;blank(ch);ch=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch;</span><br><span class="line">    *s=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (c=nc();blank(c);c=nc());</span><br><span class="line">    <span class="keyword">if</span> (IOerror)&#123;c=<span class="number">-1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fwrite-&gt;write</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Ostream_fwrite</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *buf,*p1,*pend;</span><br><span class="line">    Ostream_fwrite()&#123;buf=<span class="keyword">new</span> <span class="keyword">char</span>[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (p1==pend)&#123;</span><br><span class="line">        fwrite(buf,<span class="number">1</span>,BUF_SIZE,<span class="built_in">stdout</span>);p1=buf;</span><br><span class="line">      &#125;</span><br><span class="line">      *p1++=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">15</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">15</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1); out(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">25</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">char</span> s[<span class="number">25</span>],*s1;s1=s;</span><br><span class="line">      <span class="keyword">if</span> (!x)*s1++=<span class="string">'0'</span>;<span class="keyword">if</span> (x&lt;<span class="number">0</span>)out(<span class="string">'-'</span>),x=-x;</span><br><span class="line">      <span class="keyword">while</span>(x)*s1++=x%<span class="number">10</span>+<span class="string">'0'</span>,x/=<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(s1--!=s)out(*s1); out(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">static</span> ll mul[]=&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>,<span class="number">1000000</span>,<span class="number">10000000</span>,<span class="number">100000000</span>,</span><br><span class="line">        <span class="number">1000000000</span>,<span class="number">10000000000L</span>L,<span class="number">100000000000L</span>L,<span class="number">1000000000000L</span>L,<span class="number">10000000000000L</span>L,</span><br><span class="line">        <span class="number">100000000000000L</span>L,<span class="number">1000000000000000L</span>L,<span class="number">10000000000000000L</span>L,<span class="number">100000000000000000L</span>L&#125;;</span><br><span class="line">      <span class="keyword">if</span> (x&lt;<span class="number">-1e-12</span>)out(<span class="string">'-'</span>),x=-x;x*=mul[y];</span><br><span class="line">      ll x1=(ll)<span class="built_in">floor</span>(x); <span class="keyword">if</span> (x-<span class="built_in">floor</span>(x)&gt;=<span class="number">0.5</span>)++x1;</span><br><span class="line">      ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2);</span><br><span class="line">      <span class="keyword">if</span> (y&gt;<span class="number">0</span>)&#123;out(<span class="string">'.'</span>); <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">1</span>;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];out(<span class="string">'0'</span>),++i); print(x3);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;print(x,y);out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;<span class="keyword">while</span> (*s)out(*s++);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;<span class="keyword">while</span> (*s)out(*s++);out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="keyword">if</span> (p1!=buf)&#123;fwrite(buf,<span class="number">1</span>,p1-buf,<span class="built_in">stdout</span>);p1=buf;&#125;&#125;</span><br><span class="line">    ~Ostream_fwrite()&#123;flush();&#125;</span><br><span class="line">  &#125;Ostream;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Ostream.print(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;Ostream.println(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;Ostream.out(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;Ostream.out(x);Ostream.out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ll x)</span></span>&#123;Ostream.print(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(ll x)</span></span>&#123;Ostream.println(x);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;Ostream.print(x,y);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;Ostream.println(x,y);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;Ostream.print(s);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;Ostream.println(s);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;Ostream.out(<span class="string">'\n'</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;Ostream.flush();&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OUT_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> fastIO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!judge[i])&#123; prime[tot++]=i; p[i] = i<span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=M)<span class="keyword">break</span>; judge[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>)&#123; p[i*prime[j]] = p[i]*prime[j]; <span class="keyword">break</span>;&#125; </span><br><span class="line">            p[i*prime[j]]=p[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="keyword">return</span> p[n]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">quickmod</span><span class="params">(ll a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>; a %= c;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%c;</span><br><span class="line">        a = a*a%c; b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(ll a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="comment">// 指数循环节公式</span></span><br><span class="line">    <span class="keyword">if</span>(b*<span class="built_in">log</span>(a) &gt;= <span class="built_in">log</span>(c)) <span class="keyword">return</span> quickmod(a, b, c)+c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickmod(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,op;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树模板</span></span><br><span class="line"><span class="keyword">namespace</span> sgt &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> chg[<span class="number">1000010</span>];</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">1000010</span>][<span class="number">2</span>],cnt,root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        x=++cnt;</span><br><span class="line">        <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(son[x][<span class="number">0</span>],l,mid);</span><br><span class="line">        build(son[x][<span class="number">1</span>],mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b || l&gt;r)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=l &amp;&amp; b&gt;=r)chg[k]+=v;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(b&lt;=mid)update(a,b,son[k][<span class="number">0</span>],l,mid,v);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;mid)update(a,b,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v);</span><br><span class="line">            <span class="keyword">else</span> update(a,mid,son[k][<span class="number">0</span>],l,mid,v),update(mid+<span class="number">1</span>,b,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)<span class="keyword">return</span> v+chg[k]+val[a];</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=mid)<span class="keyword">return</span> query(a,son[k][<span class="number">0</span>],l,mid,v+chg[k]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(a,son[k][<span class="number">1</span>],mid+<span class="number">1</span>,r,v+chg[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    init(); read(n); read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(val[i]);</span><br><span class="line">    sgt::build(sgt::root,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m; t++) &#123;</span><br><span class="line">        read(op); ll x; <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            read(l); read(r); read(x);</span><br><span class="line">            sgt::update(l, r, sgt::root, <span class="number">1</span>, n, x); <span class="comment">// 区间加值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            read(l); read(r); read(x); <span class="keyword">int</span> ans = <span class="number">1</span>; mod[l] = x;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">                mod[i] = phi(mod[i<span class="number">-1</span>]); <span class="comment">// 预处理幂次的幂次的模数</span></span><br><span class="line">                <span class="keyword">if</span>(mod[i] &lt;= <span class="number">2</span>) r = i; <span class="comment">// 某幂次&lt;2那么基本就是0了可以停止了</span></span><br><span class="line">            &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--)&#123;</span><br><span class="line">                ans = slove(sgt::query(i, sgt::root, <span class="number">1</span>, n, <span class="number">0</span>), ans, mod[i]); <span class="comment">//单点查询，倒着计算</span></span><br><span class="line">            &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans%x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><h4 id="积性函数的定义"><a href="#积性函数的定义" class="headerlink" title="积性函数的定义"></a>积性函数的定义</h4><ol><li>若$f(n)$的定义域为正整数域，值域为复数，即$f:Z+→Cf:Z+→C$，则称f(n)为<strong>数论函数</strong>。</li><li>若f(n)为数论函数，且f(1)=1，对于互质的正整数p,q有f(p⋅q)=f(p)⋅f(q)，则称其为<strong>积性函数</strong>。</li><li>若f(n)为积性函数，且对于任意正整数p,q都有f(p⋅q)=f(p)⋅f(q)，则称其为<strong>完全积性函数</strong>。</li></ol><h3 id="常见的积性函数"><a href="#常见的积性函数" class="headerlink" title="常见的积性函数"></a>常见的积性函数</h3><ol><li>除数函数$\sigma_k(n) = \sum_{d|n} d^k$, 表示n的约数的k次幂和</li><li>约数个数函数$d(n) = \sigma_0(n) = \sum_{d|n} 1$ , 表示约数个数</li><li>约数和函数$\sum_{d|n} d$</li><li>欧拉函数$\phi(n)=\sum_{i=1}^{n} [(n, i) == 1]$, 对于n&gt;=2 有 $\phi(n)=\sum_{i=1}^{n} [(n, i) == 1] · i = n\phi(n)/2 $</li><li>莫比乌斯函数$u(n)$, 与恒等函数互为逆元</li><li>元函数 $e(n) = [n == 1]$</li><li>恒等函数$I(n) = 1$</li><li>单位函数$id(n) =n$</li><li>幂函数$id^k(n) = n^k$</li></ol><h4 id="两个常用的公式"><a href="#两个常用的公式" class="headerlink" title="两个常用的公式"></a>两个常用的公式</h4><ol><li>$e(n) = \sum_{d|n}u(d)$, 可以将u(d)看作是容斥的系数</li><li>$n = \sum_{d|n} \phi(d)$</li></ol><h4 id="积性函数性质"><a href="#积性函数性质" class="headerlink" title="积性函数性质"></a>积性函数性质</h4><p>若f(n)为积性函数，对于正整数$n = p_{1}^{k_1}p_{2}^{k_2}…p_{n}^{k_n}$</p><p>有$f(n)=\prod_{i=1}^{t}{f(p_i^{k_i})} $, 对于完全积性函数有$f(n)=\prod_{i=1}^{t}{f(p_i)^{k_i}}$</p><h3 id="分块技巧"><a href="#分块技巧" class="headerlink" title="分块技巧"></a>分块技巧</h3><p><a href="https://vjudge.net/problem/341399/origin" target="_blank" rel="noopener">UVALive - 7426</a></p><blockquote><p>题意：有一份包含个 bug 的n( 1≤𝑛≤$ 10^6 $)行代码，运一次到崩溃需要的时间为 r( 1≤𝑟≤$ 10^9 $)。你可以任意行添加 printf 语句来输出调试,即你知道是否在执行 printf 语句前就崩溃了。每设置一个 printf语句需要花费 p( 1≤𝑝≤$10^9$)</p><p>问最坏的情况下，最少需要多少时间可以定位bug的行数</p></blockquote><blockquote><p>解释：我们设置f(n)为n行代码debug需要的最少时间。那么对于f(n)我们时可以由前面的状态转移过来的，我们对于n行代码分成2块，那么我们就需要f ( (n+1)/2 ) + r + p的时间， 我们分成k块，那么最大的块的大小就为 (n+k-1)/k 向下取整个， 所以总体时间就是 f((n+k-1)/k) + r + (k-1)*p;</p><p>这样我们从1-n递推过来就是O(n^2) 的算法， 我们要考虑优化， 随着k增大，我们会发现有很多(n+k-1)/k 是相同，但是我们应该取相同种k最小的，所以我们反过来枚举(n+k-1)/k的大小，也就是每个块最大为l， 那么最多有(n+l-1)/l 块， 所以这样总体时间就是f(l) + r +( (n+l-1)/l )* p;</p><p>对于n√n的算法还是很吃力的，我们考虑使用记忆化搜索来降低复杂度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> n, r, p, vis[N], t;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[n] == t || n == <span class="number">1</span>) <span class="keyword">return</span> f[n];  <span class="comment">// 如果已经计算过直接返回</span></span><br><span class="line">    ll ans = <span class="number">1e18</span>+<span class="number">7</span>; vis[n] = t; <span class="comment">// 表示t组样例的时候f[n]被跟新了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(n+<span class="number">0.5</span>); j++) &#123;</span><br><span class="line">        ans = min(ans, dfs((n+j)/(j+<span class="number">1</span>)) + r + <span class="number">1L</span>L*j*p); <span class="comment">// 枚举j+1块</span></span><br><span class="line">        ans = min(ans, dfs(j)+r+((n+j<span class="number">-1</span>)/j<span class="number">-1L</span>L)*p);     <span class="comment">// 枚举每块最大为j个</span></span><br><span class="line">    &#125; <span class="keyword">return</span> f[n] = ans; <span class="comment">// 记忆化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;r, &amp;p)) &#123;</span><br><span class="line">        t++; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(n));   <span class="comment">//每组，记忆话搜索一下</span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪利克雷卷积"><a href="#迪利克雷卷积" class="headerlink" title="迪利克雷卷积"></a>迪利克雷卷积</h3><p>设f,g为两个数论函数，则满足$h(n) = \sum_{d|n} f(d)g(\frac{n}{d})$ 称为f与g的迪利克雷卷积。</p><h4 id="积性函数例题-HDU-5528"><a href="#积性函数例题-HDU-5528" class="headerlink" title="积性函数例题 HDU - 5528 "></a>积性函数例题 <a href="https://vjudge.net/problem/271392/origin" target="_blank" rel="noopener">HDU - 5528</a></h4><blockquote><p>题意：f(n)=为[0, n)种选2个数a,b且ab不为n的倍数的方案数。</p><p>求$g(n) = \sum_{d|n} f(d) \% 2^{64}$</p><p>$1 \le T \le 2e4, 1 \le n \le 1e9$</p></blockquote><blockquote><p>解析：我们先考虑f(n) ， f(n) = n*n - ab为n的倍数的方案数</p><p>即$f(n) = n^2 - \sum_{d|n}\phi(\frac{n}{d})d$</p><p>令$h(n) = \sum_{d|n}\phi(\frac{n}{d})d$</p><p>那么原式=$\sum_{d|n}d^2 - \sum_{d|n}h(d)$, 很显然这两个函数都是积性函数，我们如果直接对其质因数分解是可以做的。不过处理后面的还是很麻烦。</p><p>$\sum_{d|n}\sum_{w|d}\phi(w) * \frac{d}{w} = \sum_{w|n}w· \sum_{\frac{d}{w} |\frac{n}{w} } \phi(\frac{d}{w}) = \sum_{w|n} n = n·d(n)$</p><p>这样处理就方便了很多</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> lll = <span class="keyword">unsigned</span> __int128;</span><br><span class="line">ll a[N], num[N], cnt, prime[N], tot, n;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> j prime[i]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1L</span>L*j*j &lt;= n &amp;&amp; i &lt; tot; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">            num[cnt] = <span class="number">0</span>; a[cnt] = j;</span><br><span class="line">            <span class="keyword">while</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">                num[cnt]++; n /= j;</span><br><span class="line">            &#125; cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) a[cnt]=n,num[cnt++]=<span class="number">1</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> j</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">qp</span><span class="params">(lll a, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// 快速幂</span></span><br><span class="line">    lll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans *= a;</span><br><span class="line">        a *= a; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">p</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) ans *= (qp(a[i], num[i]*<span class="number">2</span>+<span class="number">2</span>)<span class="number">-1</span>)/(a[i]*a[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">q</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) ans *= num[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); cnt = <span class="number">0</span>; d(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%llu\n"</span>, p(n) - q(n));</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="积性函数习题-757E"><a href="#积性函数习题-757E" class="headerlink" title="积性函数习题 757E"></a>积性函数习题 757E</h4><blockquote><p>题意: $f_0 (n)$ 为 (p, q) == 1, 且p*q = n的个数, $f_{r+1}(n) = \sum_{u * v=n} \frac{f_{r}(u) + f_{r}(v)}{2} $</p><p>求$f_r(n) \%1e9+7$</p></blockquote><blockquote><p>解释： 显然$f_0(n) = 2^{n的质因子个数}$，这是一个积性函数，我们可以对其化简$f_0(n) = f_0(p_1^{k_1})f_0(p_2^{k_2})…f_0(p_t^{k_t}) = \prod_{i=1}^t(1+k_i)$</p><p>f(p^k)只与k有关，而k又是logn的，由$f_r(n)$定义可知这是一个积性函数，所以做r次前缀和就可以了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line">ll f[N][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) f[<span class="number">0</span>][i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) f[i][j] = (f[i][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j])%mod; <span class="comment">//前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q, r, n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">d</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 质因数分解</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> j prime[i]</span></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt &amp;&amp; j*j &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%j==<span class="number">0</span>)n/=j,t++; <span class="comment">// 算p^k</span></span><br><span class="line">            ans = (ans * f[r][t])%mod;  <span class="comment">//计算每个质因数的贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans = (ans * f[r][<span class="number">1</span>]) % mod; </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> j</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, d(n));</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><p>$$<br>f(n) = \sum_{d|n} g(d) &lt;=&gt; g(n) = \sum_{d|n}u(d)f(\frac{n}{d})<br>$$</p><p>这就是莫比乌斯函数，对于已知的f(n)，我们都可以利用该等式来反过来求g(n);</p><h4 id="经典例题-求互质的数对数-HDU-1695"><a href="#经典例题-求互质的数对数-HDU-1695" class="headerlink" title="经典例题-求互质的数对数 HDU - 1695"></a>经典例题-求互质的数对数 <a href="https://vjudge.net/problem/21352/origin" target="_blank" rel="noopener">HDU - 1695</a></h4><blockquote><p>题意：求1&lt;=i&lt;=b, 1&lt;=j&lt;=d 由多少对(i,j)满足gcd(i, j) = k</p></blockquote><blockquote><p>解析：我们先解决1&lt;=i&lt;=n, 1&lt;=j&lt;=m. gcd(i, j)== 1的问题</p><p>令F(d) 为有多少对i，j满足gcd(i, j) == d的倍数</p><p>f(d) 为有多少对gcd(i, j) == d， 那么我们就有$F(d) = \sum _{}f(id)$, $f(1) = \mu(1)F(1) + \mu(2)F(2)+…$</p><p>显然$f(1) = \sum_{i=1}^{min(n, m)} \mu(i) F(i)= \sum_{i=1}^{min(n, m)} \mu(i) \frac{n}{i} \frac{m}{i}$,</p><p>利用分块就可以做到$\sqrt{n}+\sqrt{m}$ 查询</p><p>所以对于原问题，b,d/=k就转成了gcd(i,j)==1, 再去减去不符合的就可以了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> mu[N], prime[N], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;N)<span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]]= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>)&#123; mu[i*prime[j]] = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">            mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">slove</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; <span class="comment">// 分块</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= l; i=tmp+<span class="number">1</span>) &#123;</span><br><span class="line">        tmp = min(l/(l/i), r/(r/i));</span><br><span class="line">        ans += (ll)(mu[tmp]-mu[i<span class="number">-1</span>])*(l/i)*(r/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b,d,k,T=<span class="number">0</span>, t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%*d%d%*d%d%d"</span>,&amp;b,&amp;d,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(!k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: 0\n"</span>,++T); <span class="keyword">continue</span>;</span><br><span class="line">        &#125; b/=k;d/=k; <span class="keyword">if</span>(b &gt; d) swap(b, d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,++T,slove(b,d) - slove(b, b)/<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GCD表中的质数"><a href="#GCD表中的质数" class="headerlink" title="GCD表中的质数"></a>GCD表中的质数</h4><blockquote><p>题意：有一个M * N的表格，行与列分别是1 - M和1 - N，格子中间写着行与列的最大公约数Gcd(i, j)(1 &lt;= i &lt;= M, 1 &lt;= j &lt;= N)。 求质数个数。</p></blockquote><blockquote><p>解析：我们枚举p,利用上面的结论就有$ans = \sum_{p}\sum_{i=1}^{\frac{n}{p}} \lfloor \frac{n}{ip} \rfloor \lfloor \frac{m}{ip} \rfloor$ , 根据这个公式的复杂度$O(T (\frac{n}{log\ n}·(\sqrt{n}+\sqrt{m}) ) )$ , 这样复杂度有点高，我们对原始做一些优化，交换两个求和符号就可以得到$\sum_{i=1}^{n}\lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor \sum_{j|i}\mu(\frac{i}{j}) \&amp;\&amp; j 为质数$</p><p>如果我们预处后面的一个求和，那么就可以做到分块查询</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N/<span class="number">5</span>], mu[N], cnt, n, m;</span><br><span class="line">ll f[N]; <span class="comment">// 为后一个求和</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++] = i; mu[i]=<span class="number">-1</span>; f[i]=<span class="number">1</span>;&#125; <span class="comment">// 对于质数f[i] = mu[1] = 1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) &#123; f[i*prime[j]] = mu[i]; <span class="keyword">break</span>; &#125; <span class="comment">//prime[j]次数为2时，之前的u都变成了0，只剩下p=prime[j],所以f[i*prime[j]]=mu[i];</span></span><br><span class="line">            f[i*prime[j]] = -f[i] + mu[i]; mu[i*prime[j]] = -mu[i]; <span class="comment">//次数为1时，u变成原来的相反数，再多上新增的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i] += f[i<span class="number">-1</span>]; <span class="comment">// 前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// 分块查询</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = min(n/(n/i), m/(m/i));</span><br><span class="line">        ans += (f[j]-f[i<span class="number">-1</span>])*(n/i)*(m/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); init();</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="keyword">if</span>(n &gt; m) swap(n, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(n, m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如此类的还有</p><ol><li>$\sum_{a=1}^{N} \sum_{b=1}^M gcd(a, b) = \sum_{d=1}^{min(N, M)} \phi(d) \lfloor \frac{N}{d} \rfloor \lfloor \frac{M}{d} \rfloor$</li><li>$\sum_{a=1}^{N} \sum_{b=1}^M lcm(a, b) = \frac{1}{4}\sum_{d=1}^{min(N, M)} \lfloor \frac{N}{d} \rfloor \lfloor \frac{M}{d} \rfloor(\lfloor \frac{N}{d} \rfloor + 1)(\lfloor \frac{M}{d} \rfloor+1) d \sum_{d’|d}d’u(d’) $</li><li>$\sum_{a=1}^{N} \sum_{b=1}^N lcm(a, b) = \sum_{i=1}^N (-i+2\sum_{j=1}^ilcm(i,j))$, 预处理后可以O(1)输出</li><li>$\sum_{i=1}^n gcd(i, n) = \sum_{d|n}\phi(d) \frac{n}{d}$</li><li>$\sum_{i=1}^n e(gcd(i, n)) = \sum_{d|n}\mu(d) \frac{n}{d}$</li><li>约束和之和$\sum_{i=1}^n = \sum_{i=1}^n i \lfloor \frac{n}{i} \rfloor$</li><li>$g(n)=\frac{n}{2}(\phi(n)+e(n))$</li><li>$\sum_{i=1}^n lcm(i, n) = n\sum_{d|n}g(\frac{n}{d})$</li><li>$\sum_{i=1}^n\sum_{j=1}^mij = \frac{n(n+1)m(m+1)}{4}$</li><li>$\sum_{i=1}^n\sum_{j=1}^mij · e(gcd(i,j)) = \sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor}ij$</li></ol><h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><p>设$S(n) = \sum_{i=1}^n f(i)$, 若存在数论函数g,设$h=f*g$, 则有$\sum_{i=1}^{n}h(i)=\sum_{i=1}^ng(i)S(\lfloor \frac{n}{i} \rfloor)$ , 化简得</p><p>$g(1)S(n)=\sum_{i=1}^nh(i)-\sum_{i=2}^ng(i)S(\lfloor \frac{n}{i} \rfloor)$,</p><p>如果我们可以$O(sqrt{n})$计算 $\sum_{i=1}^n h(i)$, O(1)计算g(n)前缀和，那么我们就可以分块查询S(n), 复杂度为$O(n^{\frac{3}{4}})$, 如果预处理前$n^{\frac{3}{4}}$ 项就可以优化到$O(n^{\frac{3}{4}})$,</p><h4 id="欧拉函数前缀和-51nod-1239"><a href="#欧拉函数前缀和-51nod-1239" class="headerlink" title="欧拉函数前缀和 51nod 1239"></a>欧拉函数前缀和 51nod 1239</h4><blockquote><p>题意：求$\sum_{i=1}^n \phi(n)$ , n &lt; 1e11;</p></blockquote><blockquote><p>解析：$S（n）= \sum_{i=1}^n i - \sum_{i=2}^n 1 *S(\lfloor \frac{n}{i} \rfloor)$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1.5e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp; <span class="comment">// 记忆化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            prime[cnt++] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) &#123; phi[i*prime[j]] = phi[i]*prime[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            phi[i*prime[j]] = phi[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) phi[i] = (phi[i<span class="number">-1</span>] + phi[i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * a % mod;</span><br><span class="line">        a = a* a %mod; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;ll inv2 = qp(<span class="number">2</span>, mod<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> phi[n]; <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">if</span>(mp.find(n) != mp.end()) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = n%mod*(n%mod+<span class="number">1</span>)%mod*inv2%mod; <span class="comment">// n*(n+1)/2</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123; <span class="comment">// 分块</span></span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans - (j-i+<span class="number">1</span>)%mod*dfs(n/i)%mod) %mod; <span class="comment">// 1 从i加到j = (j-i+1)</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=(ans%mod + mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(n)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="莫比乌斯函数前缀和"><a href="#莫比乌斯函数前缀和" class="headerlink" title="莫比乌斯函数前缀和"></a>莫比乌斯函数前缀和</h4><blockquote><p>题意：求$\sum_{i=1}^n \mu(i)$, i &lt;= 1e10</p></blockquote><blockquote><p>解析：u*I=e, 所以$S(n) = 1 - \sum_{i=2}^n S(\lfloor \frac{n}{i} \rfloor )$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;ll mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> mu[n];</span><br><span class="line">    <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="comment">// e</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i); ans -= dfs(n/i)*(j-i+<span class="number">1</span>); <span class="comment">// 和上一题一样</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b); init();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dfs(b)-dfs(a<span class="number">-1</span>)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一道习题 ：</p><p>$N^2-3N+2=\sum_{d|N} f(d)$, 求$\sum_{i=1}^Nf(i)\ mod \ 1e9+7, N \le 1e9$</p><p>这道题很容易用杜教筛做，不过他的前1e7前缀预处理可以用容斥来写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        f[i] = (i<span class="number">-1L</span>L)*(i<span class="number">-2L</span>L)%mod;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt; N; j+=i)</span><br><span class="line">            f[j] = ((f[j]-f[i])+mod)%mod; <span class="comment">// 容斥</span></span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i]=(f[i]+f[i<span class="number">-1</span>])%mod; <span class="comment">// 前缀和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extended-Eratosthenes-Sieve洲阁筛"><a href="#Extended-Eratosthenes-Sieve洲阁筛" class="headerlink" title="Extended Eratosthenes Sieve洲阁筛"></a>Extended Eratosthenes Sieve<strong>洲阁筛</strong></h3><p>洲阁筛时一种在$O(\frac{n^{\frac{3}{4}}}{log \ n})$ 时间内计算大多数积性函数的前缀和的方法。</p><p>F(x)是一个积性函数，要求在低于线性的时间内求出。当p为质数时，$F(p^c)$是关于p的低阶多项式。</p><p>对于1-n中的所有数，我们按照是否含有&gt;$\sqrt{n}$ 的质因子分为两类，则显然有<br>$$<br>\sum_{i=1}^n F(i) = \sum_{i=1 \&amp;\&amp; i没有大于\sqrt{n} 的质因数}^n F(i)(1 + \sum_{\sqrt{n}\le j \le \lfloor \frac{n}{i} \rfloor \&amp; \&amp; j为质数} F(j)\ \ \ )<br>$$</p><p>事实上，我们可以预处理 $ 1 \le i &lt; \sqrt{n} $ 的F, 那么现在的问题就是要解决</p><ol><li>$\sum_{\sqrt{n} &lt; j &lt; \le \lfloor \frac{n}{i} \&amp;\&amp;j为质数\rfloor} F(j)$</li></ol><p>我们令g(i, j) 表示[1, j]中与前i各质数互质的数的k次幂和。显然有<br>$$<br>g(i, j) = g(i-1, j)-p^k_ig(i-1, \lfloor \frac{j}{p_i}\rfloor) \<br>p_i^2 &gt; j时 g(i, j) = g(i-1, j) - p^k_i<br>$$</p><ol start="2"><li>$$\sum_{\sqrt{n} \le i \le n \&amp;\&amp; i 没有质因数&gt;\sqrt{n}} F(i)$$</li></ol><p>设f(i, j) 表示[1, j]中仅由i个质数个组成的数的F(x)之和<br>$$<br>f(i, j) = f(i-1, j) + \sum_{c \ge 1}F(p^c_i)f(i-1, \lfloor \frac{j}{p_i^c} \rfloor) \<br>当p^2_i &gt; j 时， f(i, j) = f(i-1, j) + F(p_i)<br>$$</p><h4 id="素数个数"><a href="#素数个数" class="headerlink" title="素数个数"></a>素数个数</h4><blockquote><p>题意：求1-n中素数个数，n&lt;1e11;</p></blockquote><blockquote><p>解析：对于这个虽然不是积性函数，但是我们依然可以分为两块1-$\sqrt{n}$ 和$(\sqrt{n}+1 ) - n$</p><p>前者可以O(n)预处理，后者就可以利用上面第一块的$g(\sqrt{n},n)$递推</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, res[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">//欧拉筛</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        res[i]=res[i<span class="number">-1</span>]; <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++]=i; res[i]++;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, v[N], k, last[N], g[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[n]), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, sn = <span class="built_in">sqrt</span>(n+<span class="number">0.5</span>); <span class="comment">// sqrt(n)</span></span><br><span class="line">    <span class="keyword">int</span> pos = upper_bound(prime, prime+cnt, sn) - prime; <span class="comment">// 第一个大于sqrt(n)的质数</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = n; i &gt;= <span class="number">1</span>; i = n/(n/i+<span class="number">1</span>) ) v[++tot] = n/i; <span class="comment">// 分块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) g[i]=v[i], last[i] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tot; j; j--) &#123;</span><br><span class="line">            k = v[j]/prime[i]; <span class="keyword">if</span>(k &lt; prime[i]) <span class="keyword">break</span>; <span class="comment">// 忽略j&lt;p^2</span></span><br><span class="line">            k = k &lt; sn? k: tot - n/k + <span class="number">1</span>; <span class="comment">// 找到在v中的下标</span></span><br><span class="line">            g[j] -= g[k] - (i - last[k]); <span class="comment">// 减去g[k]中已经减过的</span></span><br><span class="line">            last[j] = i + <span class="number">1</span>; <span class="comment">// 上一次处理的是第i+1个质数(从1开始)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[sn]*<span class="number">1L</span>L + g[tot] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); <span class="keyword">return</span> solve(), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>洲阁筛实现起来较为复杂，现在以及被Min_25筛替代。</p><h3 id="另外一些题"><a href="#另外一些题" class="headerlink" title="另外一些题"></a>另外一些题</h3><blockquote><p>题意：定义w(n) = n的质因子个数，$g(n)=2^{w(n)}$, 求$S(n) = \sum_{i=1}^{n}g(i)\ mod\ 1e9+7$</p><p>CCPC 杭州2016J</p></blockquote><blockquote><p>$$<br>\begin{eqnarray<em>} ans&amp;=&amp;\sum_{i=1}^ng(i)\ &amp;=&amp;\sum_{i=1}^n\sum_{d|i}\mu^2(d)\ &amp;=&amp;\sum_{i=1}^n\sum_{d|i}\sum_{k^2|d}\mu(k)\ &amp;=&amp;\sum_{k=1}^n\mu(k)\sum_{k^2|d}\lfloor\frac{n}{d}\rfloor\ &amp;=&amp;\sum_{k=1}^n\mu(k)\sum_{i=1}^{\lfloor\frac{n}{k^2}\rfloor}\lfloor\frac{n}{k^2i}\rfloor\ &amp;=&amp;\sum_{k=1}^{\sqrt{n}}\mu(k)S(\lfloor\frac{n}{k^2}\rfloor) \end{eqnarray</em>}<br>$$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++] = i; mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; N &amp;&amp; f[n]) <span class="keyword">return</span> f[n];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j; i &lt;= n; i = j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i); ans = (ans + (n/i)*(j-i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125; <span class="keyword">if</span>(n &lt; N) f[n] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, ks=<span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); init();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll k = <span class="number">1</span>; k * k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mu[k]) ans = (ans + mu[k]*S(n/k/k)) % mod;</span><br><span class="line">        &#125; <span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,ks++, (ans+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2018 四川省赛</p><p>题意：求$\sum_{i=1}^n\sum_{j=1}^i n \%(ij), n \le 1e11$</p></blockquote><blockquote><p>原式=$\sum_{i=1}^n\sum_{j=1}^i n - \lfloor \frac{n}{ij} \rfloor = n<em>n</em>(n+1)/2 -\sum_{i=1}^n\sum_{j=1}^i \lfloor \frac{n}{ij} \rfloor$</p><p>= $n<em>n</em>(n+1)/2 -1/2\sum_{i=1}^n\sum_{j=1}^n \lfloor \frac{n}{ij} \rfloor - 1/2\sum_{i=1}^n \lfloor \frac{n}{i^2} \rfloor $</p><p>欧拉筛预处理前n^{2/3}项后其他的暴力算，总复杂度是O(n^{2/3})</p><p>由于最后答案较大需要使用大数或者__int128</p><p>预处理的话，可以考虑$f[n] = \sum_{i=1}^i \lfloor \frac{n}{i}\rfloor i$, 那么$f[n]-f[n-1] = \sum_{i=1}^n i*( \lfloor \frac{n}{i}\rfloor - \lfloor \frac{n-1}{i}\rfloor) = \sum_{i|n}i$, 这个在欧拉筛中可以预处理,然后求一遍前缀和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">typedef</span> __int128 dll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line">ll n;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt, t[N];</span><br><span class="line">dll f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    f[<span class="number">1</span>] = t[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;prime[cnt++]=i; f[i]=i+<span class="number">1</span>; t[i]=i;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j]&gt;=N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                f[i*prime[j]] = f[i/t[i]] + f[i]*prime[j];</span><br><span class="line">                t[i*prime[j]] = t[i] * prime[j]; <span class="keyword">break</span>;</span><br><span class="line">            &#125; f[i*prime[j]] = f[i]*(prime[j]+<span class="number">1</span>); t[i*prime[j]] = prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) f[i] += f[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> dll <span class="title">F</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 分块求\sum_ n/i * i</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> f[n];</span><br><span class="line">    dll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans += ((dll)(j-i+<span class="number">1</span>))*(i+j)/<span class="number">2</span>*(n/i);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(dll x)</span></span>&#123; <span class="comment">// int128位数输出</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>) print(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t); init();</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">        dll ans = n; ans *= n; ans += ans * n; <span class="comment">// ans = n*n*(n+1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1L</span>L * i * i &lt;= n; i++) ans -= n/i/i*i*i;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">            j=n/(n/i);</span><br><span class="line">            ans -= ((dll)(j-i+<span class="number">1</span>))*(i+j)/<span class="number">2</span>*F(n/i);</span><br><span class="line">        &#125; print(ans/<span class="number">2</span>); <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rng-58-clj等式"><a href="#rng-58-clj等式" class="headerlink" title="rng_58-clj等式"></a>rng_58-clj等式</h3><p>$$<br>\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^cd(ijk) = \sum_{gcd(i,j)=gcd(j,k)=gcd(i,k)=1} \lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor \lfloor \frac{c}{k} \rfloor<br>$$</p><p>事实上这个等式可以扩展至任意维。</p><blockquote><p>题意：求$\sum_{i=1}^a \sum_{j=1}^b$d(ij), T, a, b &lt; 5e4;</p></blockquote><blockquote><p>原式化简为$\sum_{gcd(i,j)=1}\lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor = \sum_{g=1}^{min(a,b)} \mu(g) \sum_{i=1}^{a/g} \sum_{j=1}^{b/g}\lfloor \frac{a}{i} \rfloor \lfloor \frac{b}{j} \rfloor$</p><p>分块查询即可,代码略</p></blockquote><blockquote><p>题意：$\sum\limits_{i=1}^a\sum\limits_{j=1}^b\sum\limits_{k=1}^c d(ijk)$, a,b,c &lt; 2000</p><p>化简：$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=1}^t {\lfloor {n\over i}\rfloor}{\lfloor {m\over j}\rfloor}{\lfloor {t\over k}\rfloor} [(i,j)=1][(j,k)=1][(i,k)=1]$</p><p>=&gt;$\sum\limits_{k=1}^t {\lfloor {t\over k}\rfloor} \sum\limits_{d=1}^n \mu(d) \sum\limits_{i=1}^ {\lfloor {n\over i}\rfloor} {\lfloor {n\over i<em>d}\rfloor}[(di,k)=1] \sum\limits_{j=1}^ {\lfloor {m\over j}\rfloor} {\lfloor {m\over i</em>d}\rfloor} [(dj,k)=1]$</p><p>暴力算一下就行了(gcd可以记忆化一下)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcd __gcd</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (<span class="number">1</span>&lt;&lt;<span class="number">30</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[N], prime[N], a, b, c, gd[N][N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= d; i++) <span class="keyword">if</span>(gd[i][x] == <span class="number">1</span>) ans += d/i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) gd[i][j]=gd[j][i]=gcd(i,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c); init();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="keyword">if</span>(b &gt; c) swap(b, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">        <span class="keyword">if</span>(gcd(i, j) == <span class="number">1</span> &amp;&amp; mu[j]) ans += (a/i)*mu[j]*cal(b/j, i)*cal(c/j, i);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,ans&amp;mod), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BZOJ4176</p><p>题意：$\sum_{i=1}^n \sum_{j=1}^nd(ij), n \le 1e9$</p></blockquote><blockquote><p>化简得$= \sum_{g=1}^{n} \mu(g) \sum_{i=1}^{n/g} \sum_{j=1}^{n/g}\lfloor \frac{n}{i} \rfloor \lfloor \frac{n}{j} \rfloor$</p><p>分块查询的难调在于u(g)的前缀和，这个使用杜教筛就可以解决。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> prime[N], cnt;ll mu[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, ll&gt; mp;</span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 欧拉筛</span></span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123; prime[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>; vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; mu[i*prime[j]] = - mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll n)</span></span>&#123; <span class="comment">// 莫比乌斯前缀和</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; N) <span class="keyword">return</span> mu[n];</span><br><span class="line">    <span class="keyword">if</span>(mp.count(n)) <span class="keyword">return</span> mp[n];</span><br><span class="line">    ll ans = <span class="number">1</span>; <span class="comment">// e</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>,j; i &lt;= n; i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i); ans -= dfs(n/i)*(j-i+<span class="number">1</span>); <span class="comment">// 和上一题一样</span></span><br><span class="line">    &#125; <span class="keyword">return</span> mp[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">F</span><span class="params">(ll n)</span> </span>&#123; <span class="comment">// 分块求和</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans + (j-i+<span class="number">1</span>)%mod*(n/i)) % mod;</span><br><span class="line">    &#125; <span class="keyword">return</span> ans * ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n); ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>,j; i &lt;= n; i=j+<span class="number">1</span>) &#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        ans = (ans + (dfs(j) - dfs(i<span class="number">-1</span>) + mod)%mod*F(n/i)%mod) % mod;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h3><p>Min_25筛是一个替代洲阁晒的新产物，也是用于求解积性函数求和的问题，时间空间复杂度都比洲阁晒要优秀。</p><p>同样考虑筛质数，对1-n内所有质数求和。</p><p>设函数$S(x, j)=\sum_{i=2}^xi*[i为质数或i的最小质因子大于p_j]$ , 质数从p1开始</p><p>S(x, 0)=x*(x+1)/2 - 1; 我们要求的就是S(n, p0)</p><p>考虑转移：</p><p>$ p^2_j &gt; x, S(x, j) = S(x, j-1) \否则 S(x,j)=S(x,j-1)-f(p_j)*(S(\lfloor \frac{x}{p_j} \rfloor,j-1)-\sum_{i=1}^{j-1}f(p_i)) $</p><p>求具体积性函数和时</p><p>$G(x,j)=G(x,j+1)+\sum_{k=1}(G(\lfloor\frac{x}{p_j^k}\rfloor,j+1)-\sum_{i=1}^xf(p_i) )*f(p_j^k)+\sum_{k=2}f(p_j^k)$</p><p>能力有限，以后再学。</p></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/acm/">acm</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm/">acm</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="article-acm/网络流" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/20/acm/网络流/" class="article-date"><time datetime="2018-08-19T18:40:42.000Z" itemprop="datePublished">2018-08-20</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/08/20/acm/网络流/">网络流经典题</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p><strong>求解可行流</strong>: 给定一个网络流图, 初始时每个节点不一定平衡 (每个节点可以有盈余或不足), 每条边的流量可以有上下界, 每条边的当前流量可以不满足上下界约束. 可行流求解中一般没有源和汇的概念, 算法的目的是寻找一个可以使所有节点都能平衡, 所有边都能满足流量约束的方案, 同时可能附加有最小费用的条件 (最小费用可行流).</p><p><strong>求解最大流</strong>: 给定一个网络流图, 其中有两个特殊的节点称为源和汇. 除源和汇之外, 给定的每个节点一定平衡. 源可以产生无限大的流量, 汇可以吸收无限大的流量. 标准的最大流模型, 初始解一定是可行的 (例如, 所有边流量均为零), 因此边上不能有下界. 算法的目的是寻找一个从源到汇流量最大的方案, 同时不破坏可行约束, 并可能附加有最小费用的条件 (最小费用最大流).</p><p><strong>扩展的最大流</strong>: 在有上下界或有节点盈余的网络流图中求解最大流. 实际上包括两部分, 先是消除下界, 消除盈余, 可能还需要消除不满足最优条件的流量 (最小费用流), 找到一个可行流, 再进一步得到最大流. 因此这里我们的转化似乎是从最大流转化为可行流再变回最大流, 但其实质是将一个过程 (扩展的最大流) 变为了两个过程 (可行流 + 最大流).</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><blockquote><p>关于网络流的问题，其重点在于如何建图，而对于算法细节，其实不太重要，一般常用Dinic， 建立分层图来增广，实现起来比较简单，也有isap的，其复杂度上线都是$O(n^2m)$, 不过实际上isap的算法时间非常占优势，不过没有Dinic容易实现。</p></blockquote><h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic:"></a>Dinic:</h3><p>-&gt; 带弧优化的Dinic:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123; <span class="comment">// 建立分层图并判别能否到达汇点t.</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d); d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!d[v] &amp;&amp; e[i].w&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>; q.push(v);</span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//增广</span></span><br><span class="line">    <span class="keyword">if</span>(u == t || w == <span class="number">0</span>)<span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w; <span class="comment">//剩余流量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[u]; i != <span class="number">-1</span>; i = e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u] + <span class="number">1</span> &amp;&amp; e[i].w &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt)<span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w-dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123; <span class="comment">//最多n次增广</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) cur[i] = head[i];</span><br><span class="line">        sum += dfs(s, inf);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="经典例题："><a href="#经典例题：" class="headerlink" title="经典例题："></a>经典例题：</h4><blockquote><p>【问题1】项目发展规划（Develop）</p><p>Macrosoft® 公司准备制定一份未来的发展规划。公司各部门提出的发展项目汇总成了一张规划表，该表包含了许多项目。对于每个项目，规划表中都给出了它所需的投资或预计的盈利。由于某些项目的实施必须依赖于其它项目的开发成果，所以如果要实施这个项目的话，它所依赖的项目也是必不可少的。现在请你担任Macrosoft® 公司的总裁，从这些项目中挑选出一部分，使你的公司获得最大的净利润。</p></blockquote><blockquote><p>答： 建立N顶点代表N个项目，另外增加源s与汇t。若项目$i$必须依赖于项目$j$，则从顶点$i$向顶点$j$引一条容量为无穷大的弧。对于每个项目$i$，若它的预算$C_i$为正（盈利），则从源$s$向顶点$i$引一条容量为$C_i$的边；若它的预算$C_i$为负（投资），则从顶点$i$向汇t引一条容量为$-C_i$的边。求这个网络的最小割（S, T），设其容量C(S,T)＝F。设R为所有盈利项目的预算之和（净利润上界），那么R-F就是最大净利润；S中的顶点就表示最优方案所选择的项目。</p><p>根据最大流最小割定理，网络的最小割可以通过最大流的方法求得。</p></blockquote><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>所谓闭合子图就是给定一个有向图，从中选择一些点组成一个点集V。对于V中任意一个点，其后续节点都仍然在V中 。</p><p>所以求解闭合子图中所有点权值最大的问题就是最大权闭合子图问题。</p><p>结论：最大权闭合子图 = 正点和-最小割。</p><p>最小割可以利用最大流来解决. 设置源点与值为正的点建边，边权为点权，汇点与值为负的点建边，边权为点权绝对值，其他边的权值均为无穷，求得的最大流即最小割。</p><h3 id="D-Array-and-Operations-CodeForces-498C"><a href="#D-Array-and-Operations-CodeForces-498C" class="headerlink" title="D - Array and Operations CodeForces - 498C"></a><a href="https://vjudge.net/problem/CodeForces-498C" target="_blank" rel="noopener">D - Array and Operations</a> <a href="https://vjudge.net/problem/98145/origin" target="_blank" rel="noopener">CodeForces - 498C</a></h3><blockquote><p>题意：给出一组数，然后给出他们之间的边，构成一张由奇数点和偶数点组成的二分图，然后存在边的数可以除以他们的公约数，问最多的操作次数。</p><p>我们对于每个数都去计算他所有的因数和个数，我们可以将一个奇数点和偶数点都拆成他和他的因子们，那么每次同除左右的两个数也就是流过了具有相同因数的两个数所组成的边，所以最多的操作个数就可以跑一次最大流。具体建图方式见代码。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], prime[N], d[N], a[N], idx[<span class="number">111</span>], sum[<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, tot, cnt, s, t;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="comment">/**  --------------------------- 最大流 ------------------------------------------ **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> u,v, w, nxt;&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;e[cnt]=&#123;u,v,w,head[u]&#125;;head[u]=cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;ad(u, v, w); ad(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = <span class="number">0</span>;</span><br><span class="line">    d[s] = <span class="number">1</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!d[v] &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || w == <span class="number">0</span>) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt=w, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] == d[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        sum += dfs(s, inf);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  --------------------------- 最大流 ------------------------------------------ **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;  <span class="comment">// 先使用欧拉筛预处理1e5以下的质数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[tot++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*prime[j] &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[i*prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); <span class="comment">// 链式前向星初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ph[<span class="number">111</span>];      <span class="comment">// 用来存储每个数的因数和个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bridge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;           <span class="comment">// 对左右奇偶点相同因数建边</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, iup = ph[u].size(), jup = ph[v].size();</span><br><span class="line">    <span class="keyword">while</span>(i &lt;  iup &amp;&amp; j &lt; jup) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ph[u][i].first == ph[v][j].first) &#123; <span class="comment">// 如果有一组因数相同就建一条容量为其个数最小值的边</span></span><br><span class="line">            add(idx[u<span class="number">-1</span>]+<span class="number">1</span>+i+<span class="number">1</span>, idx[v<span class="number">-1</span>]+<span class="number">1</span>+j+<span class="number">1</span>, min(ph[u][i].second, ph[v][j].second));</span><br><span class="line">            i++;j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ph[u][i] &gt; ph[v][j]) j++;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);   </span><br><span class="line">        <span class="keyword">int</span> tmp = a[i]; sum[i] = <span class="number">0</span>; <span class="comment">// sum[i]统计因数的总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; prime[j] &lt;= tmp; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp%prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cc = <span class="number">0</span>; <span class="comment">// 计算prime[j]因数的个数</span></span><br><span class="line">                <span class="keyword">while</span>(tmp%prime[j]==<span class="number">0</span>) tmp /= prime[j],cc++;</span><br><span class="line">                ph[i].emplace_back(prime[j], cc);   <span class="comment">// 推入向量中</span></span><br><span class="line">                <span class="keyword">if</span>(i&amp;<span class="number">1</span>)add(idx[i<span class="number">-1</span>]+<span class="number">1</span>, idx[i<span class="number">-1</span>]+<span class="number">1</span>+ph[i].size(), cc); <span class="comment">//奇数点与其因数建边</span></span><br><span class="line">                <span class="keyword">else</span> add(idx[i<span class="number">-1</span>]+<span class="number">1</span>+ph[i].size(), idx[i<span class="number">-1</span>]+<span class="number">1</span>, cc);   <span class="comment">//偶数因数与其数建边</span></span><br><span class="line">                sum[i] += cc;         <span class="comment">// 统计所有因数个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>) &#123;   <span class="comment">// 存在大于1e5的因数</span></span><br><span class="line">            sum[i] += <span class="number">1</span>;</span><br><span class="line">            ph[i].emplace_back(tmp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)add(idx[i<span class="number">-1</span>]+<span class="number">1</span>, idx[i<span class="number">-1</span>]+<span class="number">1</span>+ph[i].size(), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> add(idx[i<span class="number">-1</span>]+<span class="number">1</span>+ph[i].size(), idx[i<span class="number">-1</span>]+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; idx[i] = idx[i<span class="number">-1</span>] + <span class="number">1</span> + ph[i].size(); <span class="comment">// 记录最后一个点编号</span></span><br><span class="line">    &#125;s = idx[n]+<span class="number">1</span>; t = s+<span class="number">1</span>;                     <span class="comment">// s为源点，t为汇点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)add(s, idx[i<span class="number">-1</span>]+<span class="number">1</span>, sum[i]);      <span class="comment">// s与奇数点建边</span></span><br><span class="line">        <span class="keyword">else</span> add(idx[i<span class="number">-1</span>]+<span class="number">1</span>, t, sum[i]);        <span class="comment">// 偶数点与t建边，容量为因数个数</span></span><br><span class="line">    &#125;  <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(v&amp;<span class="number">1</span>) swap(u, v);</span><br><span class="line">        bridge(u, v);                          <span class="comment">// 对奇偶数建边</span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic()), <span class="number">0</span>;       <span class="comment">// 输出最大流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><h3 id="MCMF"><a href="#MCMF" class="headerlink" title="MCMF"></a>MCMF</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123; <span class="comment">// spfa寻找是否</span></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);  <span class="comment">// 初始化最大距离</span></span><br><span class="line">    d[s] = inq[s] = <span class="number">1</span>;  </span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(s);  <span class="comment">// 双端队列优化</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); inq[u] = <span class="number">0</span>; <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + e[i].c) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].c; <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>; <span class="comment">// 进队标记</span></span><br><span class="line">                    <span class="keyword">if</span>(!q.empty() &amp;&amp; d[v] &lt; d[q.front()]) q.push_front(v);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> d[t] &lt; inf; <span class="comment">// 判断残留网络是否还有可行流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">// 增广</span></span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> w; <span class="comment">// 到达汇点停止</span></span><br><span class="line">    <span class="keyword">int</span> dlt = w, x; <span class="comment">// 剩余流量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w &gt; <span class="number">0</span> &amp;&amp; d[u]+e[i].c==d[v]) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w)); <span class="comment">// 子节点增广</span></span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            ans += x * e[i].c; <span class="comment">// 计算费用</span></span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;  <span class="comment">// 流满了可以直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt; <span class="comment">// 返回这次增广后的流量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis); <span class="comment">// 初始化</span></span><br><span class="line">            sum += dfs(s, inf);</span><br><span class="line">        &#125; <span class="keyword">while</span>(vis[t]);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum; <span class="comment">// 返回最大流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向环最小权值覆盖"><a href="#有向环最小权值覆盖" class="headerlink" title="有向环最小权值覆盖"></a>有向环最小权值覆盖</h3><blockquote><p>题意：给出n个点m条单向边边以及经过每条边的费用，让你求出走过一个哈密顿环（除起点外，每个点只能走一次）的最小费用。题目保证至少存在一个环满足条件。</p></blockquote><blockquote><p>解法：我们对于每个点都拆成前后两个点，前面的点与源连接，后面的点与汇连接，对于每条有向边u-&gt;v, u前面的点连接v后面的点，所有流量都为1。这样建图就是说每个节点都会指向后面一个节点，且不同节点指向后面的节点都不相同。</p></blockquote><p><strong>去重边</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = head[i]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == e[i].v) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">if</span>(~i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; e[i].c) e[i].c = c, e[i^<span class="number">1</span>].c = -c;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e[cnt].v = v; e[cnt].w = w; e[cnt].c = c;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt++; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ad(u, v, w, c)) ad(v, u, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题</strong></p><h3 id="HDU-3435-求无向环最小权值覆盖"><a href="#HDU-3435-求无向环最小权值覆盖" class="headerlink" title="HDU - 3435  求无向环最小权值覆盖"></a><a href="https://vjudge.net/problem/10827/origin" target="_blank" rel="noopener">HDU - 3435</a> 求无向环最小权值覆盖</h3><p>对于无向图我们只要建两条边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e4</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, T, ans,kas;</span><br><span class="line"><span class="keyword">int</span> d[N], head[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N], inq[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt, c, w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == e[i].v) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">if</span>(~i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; e[i].c) e[i].c = c, e[i^<span class="number">1</span>].c = -c;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e[cnt].v = v; e[cnt].w = w; e[cnt].c = c;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt++; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ad(u, v, w, c)) ad(v, u, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = inf;</span><br><span class="line">    d[s] = inq[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + e[i].c) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].c;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!q.empty() &amp;&amp; d[v] &lt; d[q.front()])</span><br><span class="line">                        q.push_front(v);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> d[t] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w &gt; <span class="number">0</span> &amp;&amp; d[u]+e[i].c==d[v]) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            ans += x * e[i].c;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123; <span class="comment">// MCMF 费用流</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">            sum += dfs(s, inf);</span><br><span class="line">        &#125; <span class="keyword">while</span>(vis[t]);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 初始化</span></span><br><span class="line">    ans = cnt = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>*n+<span class="number">2</span>; i++) head[i] = <span class="number">-1</span>; kas ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w); </span><br><span class="line">        add(u, v+n, <span class="number">1</span>, w);</span><br><span class="line">        add(v, u+n, <span class="number">1</span>, w); <span class="comment">// 无向图</span></span><br><span class="line">    &#125; s = <span class="number">2</span>*n+<span class="number">1</span>; t = s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; </span><br><span class="line">        add(i+n, t, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//加边</span></span><br><span class="line">        add(s, i, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    &#125; <span class="keyword">if</span>(MCMF()==n) <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, kas, ans); <span class="comment">//最大流为n则代表匹配成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: NO\n"</span>, kas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m); slove();</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-3376-最大费用流"><a href="#HDU-3376-最大费用流" class="headerlink" title="HDU - 3376  最大费用流"></a><a href="https://vjudge.net/problem/16284/origin" target="_blank" rel="noopener">HDU - 3376</a> 最大费用流</h3><blockquote><p>题意：给你一个N*N的矩阵，每个元素代表该处的权值。要求每个点只能走一次，左上角和右下角可以走两次但该处的权值只能获取一次。问你从左上角走到右下角（只能向下或右移动），再从右下角回到左上角（只能向上或左移动）所能得到的最大权值。</p><p>解析：从左上角走到右下角，再从右下角回到左上角所能得到的最大权值，我们可以转化为从【左上角起点】到【右下角终点】走两次所获的最大权值。题目要求起点终点可以走多次，其他定只能走一次。按这种思路的话起点和终点的权值我们多算了一次，最后结果要减去。</p></blockquote><p>对于最大费用流，我们只要修改一下spfa就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e7</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, T, ans;</span><br><span class="line"><span class="keyword">int</span> d[N], head[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N], inq[N];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">602</span>][<span class="number">602</span>];</span><br><span class="line"><span class="comment">/** MCMF模板 **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v, nxt, c, w;&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[cnt].v = v; e[cnt].w = w; e[cnt].c = c;</span><br><span class="line">    e[cnt].nxt = head[u];</span><br><span class="line">    head[u] = cnt++; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;ans = cnt = <span class="number">0</span>; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;<span class="keyword">if</span>(ad(u, v, w, c)) ad(v, u, <span class="number">0</span>, -c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = -inf;</span><br><span class="line">    d[s] = inq[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] &lt; d[u] + e[i].c) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].c;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>; q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> d[t] &gt; -inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w &gt; <span class="number">0</span> &amp;&amp; d[u]+e[i].c==d[v]) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            ans += x * e[i].c;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">            sum += dfs(s, inf);</span><br><span class="line">        &#125; <span class="keyword">while</span>(vis[t]);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** **/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init(); <span class="keyword">int</span> u, v, w; s = <span class="number">1</span>; t = <span class="number">2</span>*n*n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j==<span class="number">2</span> || i+j==<span class="number">2</span>*n) add(n*(i<span class="number">-1</span>)+j, n*(i<span class="number">-1</span>)+j+n*n, <span class="number">2</span>, mp[i][j]); <span class="comment">//源点汇点流量为2</span></span><br><span class="line">            <span class="keyword">else</span> add(n*(i<span class="number">-1</span>)+j, n*(i<span class="number">-1</span>)+j+n*n, <span class="number">1</span>, mp[i][j]);      <span class="comment">// 流量为1，即每个点只经过1次</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; n) add(n*(i<span class="number">-1</span>)+j+n*n, n*(i)+j, <span class="number">1</span>, <span class="number">0</span>);          <span class="comment">// 往下走</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; n) add(n*(i<span class="number">-1</span>)+j+n*n, n*(i<span class="number">-1</span>)+j+<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);      <span class="comment">// 往右走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; MCMF(); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans-mp[<span class="number">1</span>][<span class="number">1</span>]-mp[n][n]); <span class="comment">// 除去重复计算的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar())&lt;<span class="number">33</span>);</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; ch=getchar())x = x*<span class="number">10</span>+ch-<span class="string">'0'</span>; <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)  mp[i][j]=read();  <span class="comment">// 快读</span></span><br><span class="line">        &#125; slove();</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-3667-费用为流量平方倍"><a href="#HDU-3667-费用为流量平方倍" class="headerlink" title="HDU - 3667 费用为流量平方倍"></a><a href="https://vjudge.net/problem/18323/origin" target="_blank" rel="noopener">HDU - 3667</a> 费用为流量平方倍</h3><blockquote><p>题意：用 1 到 n 运送k 个货物，m条边,每条边表示 运送 x 单元货物的花费为a*x^2，c表示最大流量，求最小费用，若不能全部运送输出 -1;(c &lt;= 5)</p></blockquote><blockquote><p>解析：对于每条边，我们进行拆边。对于一条u-&gt;v的边，系数为a，最大流为c, 我们可以拆成c条，每条流量都为1，系数分别为a, 3a, 5a, 7a … 这样我们选取最小的x条，就能得到a*x^2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e5</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 费用流部分开始</span></span><br><span class="line"><span class="keyword">int</span> d[N], head[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N], inq[N];</span><br><span class="line"><span class="keyword">int</span> n, m, k, s, t, cnt, ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v, w, c, nxt;&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;e[cnt] = &#123;v, w, c, head[u]&#125;; head[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;ad(u, v, w, c); ad(v, u, <span class="number">0</span>, -c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; ans = cnt = <span class="number">0</span>; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = inf;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(s); d[s] = inq[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + e[i].c) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].c;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!q.empty() &amp;&amp; d[v] &lt; d[q.front()]) q.push_front(v);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> d[t] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w &gt; <span class="number">0</span> &amp;&amp; d[u] + e[i].c == d[v]) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            ans += x * e[i].c;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) vis[i] = <span class="number">0</span>;</span><br><span class="line">            sum += dfs(s, k);</span><br><span class="line">        &#125; <span class="keyword">while</span>(vis[t]);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 费用流部分结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k)&#123; init();</span><br><span class="line">        <span class="keyword">int</span> u, v, w, a; s = <span class="number">0</span>, t = n; add(s, <span class="number">1</span>, k, <span class="number">0</span>); <span class="comment">// 为限制节点1流量，另设立源点流向1节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;a&gt;&gt;w;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(w, k); i++) add(u, v, <span class="number">1</span>, a*(<span class="number">2</span>*i<span class="number">-1</span>)); <span class="comment">// 拆边</span></span><br><span class="line">        &#125; <span class="keyword">if</span>(MCMF() &gt;= k) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 能运送k个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合图欧拉回路"><a href="#混合图欧拉回路" class="headerlink" title="混合图欧拉回路"></a>混合图欧拉回路</h3><blockquote><p>题意：给你一个有向图，给你一个起点一个终点，需要你删除或者保留边来使得图满足下列要求：</p><ol><li>起点的入度 = 出度 - 1</li><li>重点的入度 = 出度 + 1</li><li>其他点的入度 = 出度</li></ol><p>每条边保留或者删除都有一个花费，求使得满足条件最小的花费。</p></blockquote><blockquote><p>解析：我们另设源点与汇点，对于已给的边的两端节点做一下出度与入读的统计，对于删边花费b&gt;留边花费a时，我们从b连向a一条容量为1费用为b-a的边，反之我们从a连向b一条a-b的边，表示我们先优先选择花费小的方式，但是这种方式并不能保证每个节点入度与出度的要求，我们对于入读数偏多的点建立从源点向该点的边，容量为入读-出度，反之则建从该点到汇点的边，这样跑一次最小费用流，如果跑满了就能让各个节点平衡了，此时的费用加上之前选择的就是最后的答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/** ------------------------------------ MCMF-START ------------------------------------- **/</span></span><br><span class="line"><span class="keyword">int</span> head[N], d[N], ind[N], oud[N];</span><br><span class="line"><span class="keyword">int</span> s, t, n, m, cnt, ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N], inq[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v, w, c, nxt;&#125;e[N*N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">init</span><span class="params">()</span></span>&#123;cnt=ans=<span class="number">0</span>;<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);<span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span> ind);<span class="built_in">memset</span>(oud, <span class="number">0</span>, <span class="keyword">sizeof</span> oud);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;e[cnt] = &#123;v, w, c, head[u]&#125;; head[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;ad(u, v, w, c); ad(v, u, <span class="number">0</span>, -c);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[s] = inq[s] = <span class="number">1</span>; <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_front(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(); inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] &gt; d[u] + e[i].c) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].c;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!q.empty() &amp;&amp; d[q.front()] &gt; d[v]) q.push_front(v);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> d[t] &lt; d[N<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u == t) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt=w,x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w &gt; <span class="number">0</span> &amp;&amp; d[v] == d[u] + e[i].c) &#123;</span><br><span class="line">            x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            ans += e[i].c * x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(spfa()) &#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">            sum += dfs(s, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(vis[t]);</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ------------------------------------- MCMF-END -------------------------------------- **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ks = <span class="number">1</span>; ks &lt;= T; ks++)&#123; init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t); ind[s]++;oud[t]++; <span class="comment">// 起始点和终点要满足其条件</span></span><br><span class="line">        <span class="keyword">int</span> u, v, a, b, l=<span class="number">0</span>; s = n+<span class="number">1</span>, t = s+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;a, &amp;b);</span><br><span class="line">            ans += min(a, b);                                 <span class="comment">// 选择较小的</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; b) add(v, u, <span class="number">1</span>, b-a), ind[v]++, oud[u]++;  <span class="comment">// 如果a&lt;b 则建反向的“后悔”边</span></span><br><span class="line">            <span class="keyword">else</span> add(u, v, <span class="number">1</span>, a-b);                           <span class="comment">// 否则就建 u-&gt;v 的边，费用就是删边到留边的差距</span></span><br><span class="line">        &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            l += <span class="built_in">abs</span>(oud[i] - ind[i]);                        <span class="comment">// 统计流入流出的流量总和</span></span><br><span class="line">            <span class="keyword">if</span>(ind[i] &gt; oud[i]) add(s, i, ind[i] - oud[i], <span class="number">0</span>);<span class="comment">// 流入大于流出，与源点建边</span></span><br><span class="line">            <span class="keyword">else</span> add(i, t, oud[i] - ind[i], <span class="number">0</span>);               <span class="comment">// 否则与汇点建边</span></span><br><span class="line">        &#125; a = MCMF();</span><br><span class="line">        <span class="keyword">if</span>(a == l/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ks, ans);        <span class="comment">// 流满代表各个节点平衡了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ks);             <span class="comment">// 否则就是不成立</span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h2><h3 id="无源汇的上下界网络流-SGU-194"><a href="#无源汇的上下界网络流-SGU-194" class="headerlink" title="无源汇的上下界网络流 SGU - 194"></a>无源汇的上下界网络流 <a href="https://vjudge.net/problem/20757/origin" target="_blank" rel="noopener">SGU - 194</a></h3><p>[Reactor Cooling ] (<a href="https://vjudge.net/problem/20757/origin" target="_blank" rel="noopener">SGU - 194</a> )</p><blockquote><p>题目大意：给n个点，及m根管道，每根管道用来流躺液体的，单向的，每时每刻每根管道流入=流出，要使得m条管道组成一个循环流。并满足每根管道流量限制范围为$[Li,Ri]$.</p></blockquote><blockquote><p>答：进行再构造让每条边的下界为0，对于每根管子上界容量$R_i$和下界容量$L_i$，我们让管子的容量下界变为0，上界为$R_i-L_i$ ，不过这样做就违背了每个节点的流入量=流出量这个原则，所以我们添加额外的源点和汇点与不平衡的节点建边来补全就行了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, s, t;</span><br><span class="line"><span class="keyword">int</span> head[N], cur[N], d[N], du[N], dn[M];</span><br><span class="line"><span class="comment">/** ---------------------------------最大流----------------------------------- **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v, nxt, w;&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;e[cnt]=&#123;v,head[u],w&#125;;head[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;ad(u, v, w); ad(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = <span class="number">0</span>; d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!d[v] &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v); <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || w == <span class="number">0</span>) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(d[v]==d[u]+<span class="number">1</span> &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) cur[i] = head[i];</span><br><span class="line">        ans += dfs(s, inf);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ---------------------------------最大流----------------------------------- **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, b, c;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head); <span class="comment">// 链式前向星初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); s = n+<span class="number">1</span>, t = s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;b, &amp;c);</span><br><span class="line">        add(u, v, c-b);            <span class="comment">// 添加u-&gt;v的上界为c-b的边</span></span><br><span class="line">        du[u] -= b;du[v] += b;     <span class="comment">// 统计每个点的流入流出</span></span><br><span class="line">        dn[i] = b;                 <span class="comment">// 记录每条边的流入下界</span></span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i] &gt; <span class="number">0</span>) add(s, i, du[i]);        <span class="comment">// 对于流入大于流出的，s与其建边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(du[i] &lt; <span class="number">0</span>) add(i, t, -du[i]);  <span class="comment">// 对于流出大于流入的，其与t建边</span></span><br><span class="line">    &#125; dinic();<span class="comment">// printf("%d\n", dinic());</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].w&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span>;     <span class="comment">// 如果有边没有跑满即不存在可行流</span></span><br><span class="line">    &#125; <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, e[i*<span class="number">2</span><span class="number">-1</span>].w+dn[i]);      <span class="comment">// 输出每条边的流量</span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有源汇的上下界网络流ZOJ-3229"><a href="#有源汇的上下界网络流ZOJ-3229" class="headerlink" title="有源汇的上下界网络流ZOJ - 3229 "></a>有源汇的上下界网络流<a href="https://vjudge.net/problem/20756/origin" target="_blank" rel="noopener">ZOJ - 3229</a></h3><blockquote><p>题意：一个男生给m个女神拍照，计划拍照n天，每一天男生最多给C个女神拍照，每天拍照数不能超过D张，而且给每个女神$i$拍照有数量限制[$L_i$，$R_i$]，对于每个女神n天的拍照总和至少为$G_i$，如果有解求男生最多能拍多少张照，并求每天给对应女神拍多少张照；不存在可行解输出-1。</p><p>解题思路：对于如果不存在下界$L_i$, 那么这幅图就是一个简单的最大流，我们对于源点与n天分别建一条边容量为$D_i$，每天与其对应的c个女生建一条边容量为$R_i$，每个女生与汇点建一条边容量为inf - $G_i$, 然后我们就跑一次最大流就可以了。对于有源汇的最大流，我们将其变为无源汇的网络流只需要将原来的汇点与源点建一条边，这样就是一条循环流。如此按照无源汇的方法再添加附加源与附加汇, 对于附加源与附加汇跑一次最大流来看看是否存在满足下界的可行流，如果满足，我们再跑一次初始源与初始汇的最大流来获得最大流</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, cno;</span><br><span class="line"><span class="keyword">int</span> head[N], cur[N], d[N], du[N], dn[M], id[M];</span><br><span class="line"><span class="comment">/** --------------------------------- 最大流 -------------------------- **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> v, nxt, w;&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;e[cnt]=&#123;v,head[u],w&#125;;head[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;ad(u, v, w); ad(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) d[i] = <span class="number">0</span>; d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!d[v] &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v); <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || w == <span class="number">0</span>) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u]+<span class="number">1</span> &amp;&amp; e[i].w &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, min(dlt, e[i].w));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) cur[i] = head[i];</span><br><span class="line">        ans += dfs(s, inf);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ------------------------------------ 最大流 -------------------------- **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;   <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span> du);</span><br><span class="line">    <span class="built_in">memset</span>(dn, <span class="number">0</span>, <span class="keyword">sizeof</span> dn);</span><br><span class="line">    cnt = cno = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        init(); <span class="keyword">int</span> C, D, T, L, R, x; flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            du[n+i] -= x; du[n+m+<span class="number">2</span>] += x;   <span class="comment">// 统计每个女生节点与初始汇节点的流入流出</span></span><br><span class="line">            add(n+i, n+m+<span class="number">2</span>, inf-x);         <span class="comment">// 建议上界-下界的边 = inf - Gi</span></span><br><span class="line">        &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;C, &amp;D);</span><br><span class="line">            add(n+m+<span class="number">1</span>, i, D);               <span class="comment">// 建立初始源与天数i的边，不存在下界无需统计</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;T, &amp;L, &amp;R);T++;</span><br><span class="line">                add(i, n+T, R-L); dn[cno] = L; id[cno++] = cnt<span class="number">-2</span>; <span class="comment">// 记录下界与边数id</span></span><br><span class="line">                du[i] -= L; du[n+T] += L;   <span class="comment">// 统计流量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m+<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] &gt; <span class="number">0</span>) add(n+m+<span class="number">3</span>, i, du[i]);   <span class="comment">// 补全每个节点缺少的流量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(du[i] &lt; <span class="number">0</span>) add(i, n+m+<span class="number">4</span>, -du[i]);</span><br><span class="line">        &#125; s = n+m+<span class="number">3</span>; t = n+m+<span class="number">4</span>; add(n+m+<span class="number">2</span>, n+m+<span class="number">1</span>, inf); <span class="comment">// 变无源汇</span></span><br><span class="line">        <span class="keyword">int</span> ans = dinic(); <span class="comment">//printf("%d\n", dinic()); </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span>) &#123; flag = <span class="number">1</span>; <span class="built_in">puts</span>(<span class="string">"-1\n"</span>); <span class="keyword">break</span>; &#125; <span class="comment">// 检测是否所有从附加源出发的边都跑满了</span></span><br><span class="line">        &#125; <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        s = n+m+<span class="number">1</span>; t=s+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic());      <span class="comment">// 跑 初始源与初始汇的 最大流</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cno; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dn[i]+e[id[i]^<span class="number">1</span>].w);  <span class="comment">// 输出每条边流量</span></span><br><span class="line">        &#125; <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有源汇的上下界最小流-SGU-176"><a href="#有源汇的上下界最小流-SGU-176" class="headerlink" title="有源汇的上下界最小流 SGU - 176 "></a>有源汇的上下界最小流 <a href="https://vjudge.net/problem/11025/origin" target="_blank" rel="noopener">SGU - 176</a></h3><blockquote><p>题目：有一个工业加工生产的机器，源为1，汇为n，中间生产环节有货物加工数量限制，输出u v z c， 当c等于1时表示这个加工的环节必须对纽带上的货物全部加工（即上下界都为z），c等于0表示没有下界，求节点1（起点）最少需要投放多少货物才能传送带正常工作。</p></blockquote><blockquote><p>解析：如果只是普通的最小流，我们只要跑一次从汇到源的最大流，那么此时我们可以根据残留网络中的边统计出最小流。此题，我们先不考虑最小流，那就是一个源为1，汇为n，的一个上下界网络流，统计每个节点的流入流出就可以判断出是否存在可行解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1.09e4</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, s, t;</span><br><span class="line"><span class="keyword">int</span> head[N], cur[N], du[N], dn[M], d[N];</span><br><span class="line"><span class="comment">/** ----------------------------  最大流  ---------------------------------------- **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> w, nxt, v;&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;e[cnt] = &#123;w, head[u], v&#125;;head[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;ad(u, v, w); ad(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">2</span>; i++) d[i]=<span class="number">0</span>; d[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!d[v] &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                q.push(v); <span class="keyword">if</span>(v == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || w == <span class="number">0</span>) <span class="keyword">return</span> w;</span><br><span class="line">    <span class="keyword">int</span> dlt = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; ~i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(d[v] == d[u]+<span class="number">1</span> &amp;&amp; e[i].w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = dfs(v, min(e[i].w, dlt));</span><br><span class="line">            e[i].w -= x; e[i^<span class="number">1</span>].w += x;</span><br><span class="line">            dlt -= x; <span class="keyword">if</span>(!dlt) <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> w - dlt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">2</span>; i++) cur[i] = head[i];</span><br><span class="line">        ans += dfs(s, inf);</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ----------------------------  最大流  ---------------------------------------- **/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">int</span> u, v, z, c; s = n+<span class="number">1</span>; t = s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;v, &amp;z, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(c) &#123;</span><br><span class="line">            add(u, v, <span class="number">0</span>); dn[i] = z; <span class="comment">// 记录边下界</span></span><br><span class="line">            du[u] -= z;  du[v] += z; <span class="comment">// 统计流入流出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> add(u, v, z);         <span class="comment">// 只有上界的边</span></span><br><span class="line">    &#125; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i] &gt; <span class="number">0</span>) add(s, i, du[i]); <span class="comment">// 附加源建边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(du[i] &lt; <span class="number">0</span>) add(i, t, -du[i]); <span class="comment">// 附加汇建边</span></span><br><span class="line">    &#125; <span class="keyword">int</span> tmp = cnt; add(n, <span class="number">1</span>, inf); dinic();  <span class="comment">// 转无源汇跑最大流</span></span><br><span class="line">    <span class="keyword">int</span> ans = e[tmp^<span class="number">1</span>].w;                      <span class="comment">// 记录可行流中的流量（即n-&gt;1的边中的流量）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; ~i; i = e[i].nxt) &#123; </span><br><span class="line">        <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Impossible"</span>), <span class="number">0</span>;  <span class="comment">// 无可行流则结束</span></span><br><span class="line">    &#125; e[tmp].w = <span class="number">0</span>; e[tmp^<span class="number">1</span>].w = <span class="number">0</span>;s = n; t = <span class="number">1</span>; ans -= dinic(); <span class="comment">// 去除1-n之间的边并跑一次最小流</span></span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) &#123;                                                <span class="comment">// 能去除的流量比可行流还要大</span></span><br><span class="line">        add(n+<span class="number">1</span>, <span class="number">1</span>, -ans);       <span class="comment">// 附加源与源建一条边，容量为差的边</span></span><br><span class="line">        s = n+<span class="number">1</span>; t = n; ans = <span class="number">0</span>; <span class="comment">// 即最小流为0</span></span><br><span class="line">        dinic();                 <span class="comment">// 补足可行流</span></span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);             <span class="comment">// 输出去除可以去除的流量后的最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*m; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, dn[i/<span class="number">2</span>]+e[i^<span class="number">1</span>].w); <span class="comment">// 输出每条边的流量  </span></span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/acm/">acm</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm/">acm</a></li></ul></div><div class="clearfix"></div></div></div></article><article id="article-acm/hash" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/04/acm/hash/" class="article-date"><time datetime="2018-08-03T20:06:58.126Z" itemprop="datePublished">2018-08-04</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/08/04/acm/hash/">hash在ACM种的应用</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>有时候我们要统计很大的数的个数时，但是这个时候我们又开不下这么大的数组，我们常常可以借助map，或者hash_table之类的工具。</p><h2 id="Hash-统计数字个数"><a href="#Hash-统计数字个数" class="headerlink" title="Hash 统计数字个数"></a>Hash 统计数字个数</h2><p>有时候map占用的数据也非常大， 我们可以利用链式前向星来代替链表实现一个简易的hash来统计每个数的个数，这个所占用的空间比map要小的多。</p></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/acm/">acm</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm/">acm</a></li></ul></div><p class="article-more-link"><a href="/2018/08/04/acm/hash/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="post-hadoop/wordcount" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/03/hadoop/wordcount/" class="article-date"><time datetime="2018-08-03T13:10:33.000Z" itemprop="datePublished">2018-08-03</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/08/03/hadoop/wordcount/">Hadoop的使用</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Hadoop-WordCount"><a href="#Hadoop-WordCount" class="headerlink" title="Hadoop WordCount"></a>Hadoop WordCount</h1><p>wordCount 是Hadoop里面最经典的入门程序。</p><p>我们可以先写一个Word Count.java的程序:</p></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/Hadoop/">Hadoop</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li></ul></div><p class="article-more-link"><a href="/2018/08/03/hadoop/wordcount/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="post-hadoop/Linux安装hadoop" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/08/03/hadoop/Linux安装hadoop/" class="article-date"><time datetime="2018-08-03T12:10:33.000Z" itemprop="datePublished">2018-08-03</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/08/03/hadoop/Linux安装hadoop/">Hadoop的安装</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Hadoop-Get-started"><a href="#Hadoop-Get-started" class="headerlink" title="Hadoop Get started"></a>Hadoop Get started</h1><p>Hadoop 的安装教程比较杂乱，并且对于1.x版本和2.x版本有很大的差异，虽然先在3.0的也已经出来了，但是还是先用2.0的比较稳定些。由于在windows安装hadoop确实比较鸡肋，我是在云服务器上安装的，ssh连接然后搞搞的。</p></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/Hadoop/">Hadoop</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li></ul></div><p class="article-more-link"><a href="/2018/08/03/hadoop/Linux安装hadoop/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="article-machineLearning/Lesson1" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2018/03/19/machineLearning/Lesson1/" class="article-date"><time datetime="2018-03-19T11:40:42.000Z" itemprop="datePublished">2018-03-19</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2018/03/19/machineLearning/Lesson1/">机器学习初识</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="K-Means-K-均值-gt-聚类"><a href="#K-Means-K-均值-gt-聚类" class="headerlink" title="K-Means(K-均值) -&gt;聚类"></a>K-Means(K-均值) -&gt;聚类</h1><p>K-Means 是一种使用广泛的聚类的算法，将各种聚类子集内的所有数据样本的<strong>均值</strong>作为该聚类的代表点。</p><p>算法主要思想：通过迭代把数据集划分为不同的类别，使得评价聚类性能的准则函数达到最优，从而使得生成的每个聚类类内紧凑，类间独立。</p><p>由于每次都要计算所有的样本与每一个质心之间的距离，在大规模数据集上收敛速度较慢。</p><h2 id="算法思想及步骤"><a href="#算法思想及步骤" class="headerlink" title="算法思想及步骤"></a>算法思想及步骤</h2><ol><li>设置 k ， 以及k个聚类中心$u_1, u_2, …, u_k$</li><li>分组：<ul><li>将样本分配给距离最近的聚类中心</li><li>由这些样本构造不相交(non-overlapping)的聚类</li></ul></li><li>确定中心： 用个聚类的<strong>均值向量</strong>作为新的聚类中心</li><li>重复2，3直至算法收敛即聚类中心达到稳定。</li></ol><h2 id="算法要点"><a href="#算法要点" class="headerlink" title="算法要点"></a>算法要点</h2><ol><li><p>选定某种距离作为数据样本间的相似性度量</p><blockquote><p>k-means聚类算法不适合处理离散型属性，对连续性属性比较适合</p><p>计算样本之间的距离时，根据实际需要选择距离测度作为算法的相似性度量，如欧式距离，曼哈顿距离(各维差的绝对值之和)，马氏距离(两个服从同一分布并且其协方差矩阵为Σ的随机变量之间的差异程度)</p></blockquote></li><li><p>选择评价聚类性能的准则函数</p><blockquote><p>k-means聚类算法使用误差平方和准则函数来评价聚类性能。</p><p>$$cost·Function = \sum_{i=1}^{k}\sum_{x_j \in S_i }(x_j - u_i)^2$$</p></blockquote></li><li><p>相似性的计算根据一个簇中对象的平均值(均值向量)来进行</p></li></ol></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/">math</a></li></ul></div><p class="article-more-link"><a href="/2018/03/19/machineLearning/Lesson1/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="article-随笔集/2017年末总结" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/12/29/随笔集/2017年末总结/" class="article-date"><time datetime="2017-12-29T13:40:42.000Z" itemprop="datePublished">2017-12-29</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2017/12/29/随笔集/2017年末总结/">2017年末总结</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="2017-年末总结-amazed"><a href="#2017-年末总结-amazed" class="headerlink" title="2017 年末总结 :amazed:"></a>2017 年末总结 :amazed:</h1><blockquote><p>author: huchi</p><p>文体: 呼式体</p></blockquote><p>让我离20岁更近一步的一年过去了，这一年我学到了很多东西，在点外卖方面有了很多不错的经验以及一些special的视角和实战经验。本来这一年也应该是平平淡淡过去的，写这个总结的原因是因为之前刚刚点了一旦外卖，有感而发。</p><p>一来谈谈自己一年所学的成果，二来谈谈自己的刚刚点的外卖。</p></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/随笔/">随笔</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div><p class="article-more-link"><a href="/2017/12/29/随笔集/2017年末总结/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="article-设计模式/python设计模式(4)" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/12/21/设计模式/python设计模式(4)/" class="article-date"><time datetime="2017-12-21T10:40:42.000Z" itemprop="datePublished">2017-12-21</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2017/12/21/设计模式/python设计模式(4)/">python设计模式(四)</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h1><p>模式不是独立工作的，模式通常需要同时使用并加以组合，以实现特定的设计解决方法。</p><p>MVC不仅是一种实现用户界面的软件模式，也是一种易于修改维护的架构。通常分为3个基本部分：Model,View,Control。</p><p>工作机制：模型提供数据和业务逻辑(如存储查询信息)，视图负责数据的展示，控制器是两者的粘合剂，根据用户需求来协调模型和视图。模型可以独立工作，视图和控制器依赖于模型。</p><p>MVC涉及的主要类：</p><ul><li>模型类定义针对数据的所有操作，并提供与数据使用方法有关的方法</li><li>视图类代表用户界面。他提供相应的方法，帮助我们根据上下文和应用程序的需要来构建Web或GUI界面。不应该包含自己的任何逻辑，只应该显示收到的数据</li><li>控制器类从请求接收数据，并将其发送到系统的其他部分，它需要提供用于路由请求的方法。</li></ul></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/python/">python</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul></div><p class="article-more-link"><a href="/2017/12/21/设计模式/python设计模式(4)/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="article-设计模式/python设计模式(3)" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/12/20/设计模式/python设计模式(3)/" class="article-date"><time datetime="2017-12-19T16:40:42.000Z" itemprop="datePublished">2017-12-20</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2017/12/20/设计模式/python设计模式(3)/">python设计模式(三)</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>创建型模式的工作原理是基于对象的创建机制的。由于这些模式隔离了对象的创建细节，使得代码能够与要创建的对象的类型相互独立。</p><p>结构型模式用于设计对象和类的结构，从而使他们可以相互协作以获得更大的结构。</p><p>行为型模式，主要关注的是对象的责任，用来处理对象之间的交互，以实现更大的功能。</p><p>观察者设计模式是最简单的行为型模式之一。</p><p><strong>主要目标:</strong></p><ul><li>定义了对象之间的一对多的依赖关系，从而使一个对象中的任何改动都将通知给其他依赖对象。</li><li>封装主题的核心组件</li></ul><p><strong>应用场景</strong>：</p><ul><li>分布式系统中实现事件服务</li><li>用作新闻机构框架</li><li>股票市场也是观察者模式的一个大型场景</li></ul></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/python/">python</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul></div><p class="article-more-link"><a href="/2017/12/20/设计模式/python设计模式(3)/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><article id="article-设计模式/python设计模式(2)" class="article article-type-article" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/12/19/设计模式/python设计模式(2)/" class="article-date"><time datetime="2017-12-18T16:40:42.000Z" itemprop="datePublished">2017-12-19</time></a></div><div class="article-inner"><input type="hidden" class="isFancy"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/2017/12/19/设计模式/python设计模式(2)/">python设计模式(二)</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="工厂模式：建立创建对象的工厂"><a href="#工厂模式：建立创建对象的工厂" class="headerlink" title="工厂模式：建立创建对象的工厂"></a>工厂模式：建立创建对象的工厂</h1><p>“工厂”表示一个负责创建其他类型对象的类。作为一个工厂的类有一个对象以及与它关联的多个方法。客户端使用某些参数调用此方法，之后工厂会据此创建所需类型的对象，然后将他们返回给客户端。</p><p>优点：</p><ul><li>松耦合性，对象的创建可以独立于类的实现</li><li>客户端无需了解创建对象的类，但是照样可以使用它来创建对象，它只需要知道传递的接口、方法和参数，就能够创建所需类型的对象，简化了客户端的实现</li><li>可以轻松地在工厂中添加其他类来创建其他类型的对象，而这无需更改客户端代码，最简单的情况下，客户端只需要传递另一个参数就可以了。</li><li>工厂还可以重用现有对象。但是如果客户端直接创建对象的话，总是创建一个新的对象。</li></ul><p>3种变体：</p><ul><li>简单工厂模式：允许接口创建对象，但不会暴露对象的创建逻辑</li><li>工厂方法模式：允许接口创建对象，但使用哪个类来创建对象，则是交由子类决定的。</li><li>抽象工厂模式：能够创建一系列相关的对象而无需指定/公开其具体类的接口。该模式能够提供其他工厂的对象，在其内部创建其他对象。</li></ul></div><div class="article-info article-info-index"><div class="article-category tagcloud"><a class="article-category-link" href="/categories/python/">python</a></div><div class="article-tag tagcloud"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul></div><p class="article-more-link"><a href="/2017/12/19/设计模式/python设计模式(2)/#more">阅读全文 >></a></p><div class="clearfix"></div></div></div></article><nav id="page-nav"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a></nav></div><footer id="footer"><div class="outer"><div id="footer-info"><div class="footer-left"><i class="fa fa-copyright"></i> 2018 呼哧</div><div class="footer-right"><a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a> Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i></div></div><div class="visit"><span id="busuanzi_container_site_pv" style="display:none"><span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span> </span></span><span>| </span><span id="busuanzi_container_page_pv" style="display:none"><span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span></span></span></div></div></footer></div><script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script><script>$(document).ready(function(){if(-1<window.navigator.userAgent.indexOf("iPad")||"none"===$(".left-col").css("display")){var a=["#9db3f4","#414141","#e5a859","#f5dfc6","#c084a0","#847e72","#cd8390","#996731"],c=Math.ceil(Math.random()*(a.length-1));$("body").css({"background-color":a[c],"background-size":"cover"})}else{var e="url(/background/bg-x.jpg)".replace(/x/gi,Math.ceil(5*Math.random()));$("body").css({background:e,"background-attachment":"fixed","background-size":"cover"})}})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});</script><script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div class="scroll" id="scroll"><a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a> <a href="#comments" onclick="load$hide()" title="查看评论"><i class="fa fa-comments-o"></i></a> <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a></div><script>var oOpenInNew={archives:".archive-article-title",miniArchives:"a.post-list-link",friends:"#js-friends a",socail:".social a"};for(var x in oOpenInNew)$(oOpenInNew[x]).attr("target","_blank")</script><script>var titleTime,originTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="(つェ⊂) 我藏好了哦~ "+originTitle,clearTimeout(titleTime)):(document.title="(*´∇｀*) 被你发现啦~ "+originTitle,titleTime=setTimeout(function(){document.title=originTitle},2e3))})</script><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body>